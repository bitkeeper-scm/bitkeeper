/*
 * Copyright (c) 2006-2007 BitMover, Inc.
 */
#include <stdio.h>
#include <stdarg.h>
#include "tclInt.h"
#include "tclCompile.h"
#include "tclRegexp.h"
#include "Lcompile.h"
#include "Lgrammar.h"
#include "Last.h"

/*
 * Special obj type to store deep pointers. These CANNOT ever go out of the
 * engine (ie, stored in a var or returned), and they do not remain valid
 * after any command or expression that may access variables.
 *
 * These are generated by L_DeepDiveIntoStruct and are consumed immediately
 * after that.
 */

Tcl_ObjType LdeepPtrType = {
	"l-deepType",			/* name */
	NULL,				/* freeIntRepProc */
	NULL,				/* dupIntRepProc */
	NULL,				/* updateStringProc */
	NULL				/* setFromAnyProc */
};

/*
 * To implement the defined() operator, we have an L-specific type to
 * represent the undefined value of array, hash, or struct members
 * when they dynamically are brought into life by an array
 * auto-extend.  We create one object of this type and dup it as the
 * value of all undefined objects.
 */

private void
undef_free_internal_rep(Tcl_Obj *o)
{
	o->bytes  = NULL;
	o->length = 0;
}

/*
 * Return an error if someone tries to convert a value of undef type
 * to anything else.
 */
private int
undef_set_from_any(Tcl_Interp *interp, Tcl_Obj *o)
{
	Tcl_SetObjResult(interp,
			 Tcl_NewStringObj("cannot read undefined value", -1));
	return (TCL_ERROR);
}

/*
 * Get a pointer to the "undefined" object pointer, allocating it the
 * first time it is needed.
 */
static Tcl_Obj *undef_obj = NULL;

private Tcl_Obj **
get_undef_obj()
{
	unless (undef_obj) {
		undef_obj = Tcl_NewObj();
		Tcl_InvalidateStringRep(undef_obj);
		undef_obj->bytes = "";
		undef_obj->typePtr = &L_UndefType;
		Tcl_IncrRefCount(undef_obj);
	}
	return (&undef_obj);
}

Tcl_ObjType L_UndefType = {
	"undef",
	undef_free_internal_rep,
	NULL,
	NULL,
	undef_set_from_any
};

/*
 * WARNING: this may break if dicts change their internal rep!
 * Dicts do not expose their guts; we need access to the hash table here.
 * LMXXX - can someone tell me what the #if 0 part is?
 */
#if 0
typedef struct Dict {
    Tcl_HashTable table;	/* Object hash table to store mapping in. */
    struct ChainEntry *entryChainHead;	/* Linked list of all entries in the
				 * dictionary. Used for doing traversal of the
				 * entries in the order that they are
				 * created. */
    struct ChainEntry *entryChainTail;	/* Other end of linked list of all
				 * entries in the dictionary. Used for doing
				 * traversal of the entries in the order that
				 * they are created. */
    int epoch;			/* Epoch counter */
    int refcount;		/* Reference counter (see above) */
    Tcl_Obj *chain;		/* Linked list used for invalidating the
				 * string representations of updated nested
				 * dictionaries. */
} Dict;
#else
typedef struct Dict {
	Tcl_HashTable table;	/* Object hash table to store mapping in. */
} Dict;
#endif

/*
 * Macro to find out if we can compile a regexp inline: type is set to 1 if no
 * modifiers, 'i' if only -nocase, 0 otherwise.
 */
#define REGEXP_TYPE(regexp, type) \
    {				  \
	L_expr *local = regexp; \
				      \
	type = (local->c) ? 0 : 1;			       \
	if (local->c && !strchr(local->c->u.string, 'g')) {		\
	    if (strchr(local->c->u.string, 'i')) {	       \
		type = 'i';					 \
	    } \
	} \
    }

/*
 * Macro to detect (some cases) when a string comparison to "0" is superfluous
 */
#define EXPR_IS_VALID_BOOLEAN(expr)				\
	(((type = L_expr_type(expr)) != NULL) &&		\
	((type->kind == L_TYPE_FLOAT) ||			\
	(type->kind == L_TYPE_INT) ||				\
	(type->kind == L_TYPE_NUMBER)))


/* Insure single tempvar per bytecode obj for non-conflicting usage */
#define SINGLE_TEMPVAR "%% L: single tempvar for non-conflicting usage"
#define get_single_tempvar() \
    (TclFindCompiledLocal(SINGLE_TEMPVAR, strlen(SINGLE_TEMPVAR),	\
	    1, lframe->envPtr->procPtr))

/* Grab the offset of the next instruction to be issued.  Stolen from
   tclCompCmds.c. */
#define CurrentOffset(envPtr)	((envPtr)->codeNext - (envPtr)->codeStart)

#define looks_like_pattern_func(name, len, p) \
    (((len = strlen(name)) > 0) &&					\
	(name[0] >= 'A') && (name[0] <= 'Z') &&				\
	(p = strchr(name, '_')))

L_compile_frame *lframe = NULL;
static	Tcl_HashTable *L_struct_types = NULL;
static	L_function_decl *L_enclosing_func = NULL;
Tcl_Obj *L_errors = NULL;
Tcl_Obj	*stringBuf;
int	L_line_number = 0;
char	*L_source_file = "";
void	*L_current_ast = NULL;
int	L_interactive = 0;

/* The source of the script that we're compiling. */
private	char	*L_script = NULL;
private	int	L_scriptLen = 0;

/*
 * The token offset is the number of bytes between the beginning of the input
 * string and the beginning of a token.  It's tracked by the lexer, but we
 * declare it here so that it can be reset before lexing begins.
 */
int	L_token_offset = 0;
int	L_prev_token_len = 0;


private int gensym_counter = 0;  /* used to create unique names */

/*
 * The table we store typedef information in.  Use L_typedef_table() to access
 * it.
 */
Tcl_HashTable *__L_typedef_table = NULL;

/*
 * This table stores the names of all L functions seen.  The parser uses it
 * via the interface below to identify calls to pattern functions such as
 * Frame_*.
 */
Tcl_HashTable *__L_func_table = NULL;

/*
 * We use the include table to track files that have already been included,
 * since L's include() will only ever include a file once.
 */
Tcl_HashTable *__L_include_table = NULL;

/* these are generated by lex: */
void	*L__scan_bytes (const char *bytes, int len);
void	L__delete_buffer(void *buf);

/* functions local to this file */
private void L_free_ast(Ast *ast);
private int global_symbol_p(L_symbol *symbol);
private void fixup_struct_type(L_type *type);
private L_type *lookup_struct_type(char *tag);
private int L_push_set_of_indices(L_expr *expr, L_type *type,
	int *depthPtr, Tcl_Obj **countsPtr);
private L_symbol *import_global_symbol(L_symbol *var);
private char *gensym(char *name);
private void L_write_index(L_symbol *var, L_expr *index,
  L_expr *expr, L_expr *rval, int post_incr_p);
private Tcl_HashTable *L_typedef_table(void);
private L_expr *reference_mangle(char *name);
private int param_passed_by_name_p(L_var_decl *p);
private L_symbol *L_get_local_symbol(L_expr *name, int error_p);
private void compile_initializer(L_initializer *init, L_type *type);
private void compile_blank_initializer(L_type *type);
private int LDumpAstNodes(Ast *node, void *data, int order);
private int push_parameters(char *funcname, L_expr *parameters);
private void L_push_pointer(L_expr *lval);
private L_compile_frame *enclosing_loop_frame(int include_switch_p);
private void fixup_jumps(CompileEnv *envPtr, Jumps *jumps, int targetOffset);
private Proc *Begin_Proc(void);
private void Finish_Proc(Proc *procPtr, char *name);
private int instruction_for_l_op(int op);
private void regsub_for_assignment(char *varName, int varIndex, L_expr *regexp);
private void track_lineInfo(int codeOffset, int srcOffset, int len);
private int push_regexp_modifiers(L_expr *regexp);
private void L_do_includes(Tcl_Interp *interp, const char *str, int numBytes);
private int fresh_include_p(Tcl_Interp *interp, const char *file);
private Tcl_HashTable *L_include_table(void);
private char *L_include_search(Tcl_Interp *interp, const char *file);
private Tcl_HashTable *L_func_table(void);
private void L_compile_push(L_expr *expr);
private int LParseScript(Tcl_Interp *interp, CONST char *str, int numBytes,
    Ast **L_ast);
private int LCompileScript(Tcl_Interp *interp, CompileEnv *envPtr, void *ast,
    int opts);
private void L_frame_push(Tcl_Interp *interp, CompileEnv *envPtr, void *block);
private void L_frame_pop(void);
private int L_compile_toplevels(L_toplevel *stmt);
private void maybeFixupEmptyCode(L_compile_frame *frame);
private void L_compile_function_decl(L_function_decl *fun);
private void L_compile_struct_decl(L_type *decl);
private void L_compile_global_decls(L_var_decl *decl);
private void L_compile_stmts(L_stmt *stmt);
private void L_compile_var_decls(L_var_decl *var);
private void L_compile_expr(L_expr *expr, int discard);
private int L_compile_exprs(L_expr *expr, int discard);
private void L_compile_if_unless(L_if_unless *cond);
private void L_compile_loop(L_loop *loop);
private void L_compile_foreach_loop(L_foreach_loop *loop);
private void L_compile_foreach_loop_array(L_foreach_loop *loop);
private void L_compile_foreach_loop_hash(L_foreach_loop *loop);
private L_type *L_compile_index(L_type *index_type, L_expr *index);
private void L_return(int value_on_stack_p);
private L_symbol *L_make_symbol(L_expr *name, L_type *type, int localIndex);
private void L_compile_parameters(L_var_decl *param);
private void L_compile_defined(L_expr *lval);
private void L_compile_block(L_block *block);
private void L_compile_break(L_stmt *stmt);
private void L_compile_continue(L_stmt *stmt);
private void L_compile_incdec(L_expr *expr);
private void L_compile_unop(L_expr *expr);
private void L_compile_interpolated_string(L_expr *expr);
private void L_compile_assignment(L_expr *expr);
private void L_compile_short_circuit_op(L_expr *expr);
private void L_compile_twiddle(L_expr *expr);
private void L_push_var(L_expr *expr);
private void l_push_literal(L_expr *expr);
private void L_compile_binop(L_expr *expr);

/* we keep track of each AST node we allocate and free them all at once */
Ast	*ast_trace_root = NULL;

/*
 * If TCL encounters an lang(L) directive while evaluating code directly,
 * e.g., from an upvar, it will enter the L compiler via L_LObjCmd().
 */
int
Tcl_LObjCmd(
	ClientData clientData,
	Tcl_Interp *interp,
	int	objc,
	Tcl_Obj *CONST objv[])
{
	int	stringLen;
	char	*stringPtr;
	Ast	*ast;
	static	CONST char *options[] = { "-poly", "-nowarn", NULL };
	enum	options { L_POLY, L_NOWARN };
	int	index, i;
	int	opts = 0;

	L_trace("Entering L compiler via Tcl_LObjCmd");

	if (objc < 2) {
		Tcl_WrongNumArgs(interp, 1, objv, "?options? l-program");
		return (TCL_ERROR);
	}

	/* option parsing -- add flags to :opts */
	for (i = 1; i < objc - 1; i++) {
		if (Tcl_GetIndexFromObj(interp, objv[i],
			options, "option", 0, &index) != TCL_OK) {
			return (TCL_ERROR);
		}
		switch((enum options)index) {
		    case L_POLY:
			L_trace("poly mode");
			opts |= L_OPT_POLY;
			break;
		    case L_NOWARN:
			L_trace("nowarn mode");
			opts |= L_OPT_NOWARN;
			break;
		    default:
			L_bomb("bad option that "
			    "Tcl_GetIndexFromObj should've caught");
		}
	}
	stringPtr = Tcl_GetStringFromObj(objv[objc - 1], &stringLen);
	if (LParseScript(interp, stringPtr, stringLen, &ast) != TCL_OK) {
		return (TCL_ERROR);
	}
	if (ast == NULL) return (TCL_OK);	/* empty script */
	return (LCompileScript(interp, NULL, ast, opts));
}

/*
 * If TCL encounters an L pragma while compiling TCL code, for example when
 * processing an entire file in TclCompileScript(), it will enter L via
 * TclCompileLCmd().  In that case, we get a pointer to the toplevel
 * compilation environment, so we have the option of emitting global code.
 *
 * If there is an error during L compilation, we return TCL_ERROR.  However,
 * the error only causes TCL to defer evaluation of the L pragma until
 * runtime, at which point Tcl_LObjCmd() will recompile the L code and hit the
 * same error.
 */
int
TclCompileLCmd(
	Tcl_Interp *interp,
	Tcl_Parse *parsePtr,
	Command *cmdPtr,		// unused
	CompileEnv *envPtr)
{
	Tcl_Token *lTokenPtr;
	Ast	*ast;

	L_trace("Entering L compiler via TclCompileLCmd");
	if (parsePtr->numWords != 2) {
		//L_bomb("Assertion failed in TclCompileLCmd: we expected 2 "
		//"words but got %d.", parsePtr->numWords);
		return (TCL_ERROR);
	}
	// advance to the second token
	lTokenPtr = parsePtr->tokenPtr + parsePtr->tokenPtr->numComponents + 1;
	// the first component of the second token contains the code
	if (LParseScript(interp,
		lTokenPtr[1].start, lTokenPtr[1].size, &ast) != TCL_OK) {
		return (TCL_ERROR);
	}
	if (ast == NULL) {
		/*
		 * empty script, which is fine, but Tcl expects us to
		 * leave a value on the stack.
		 */
		L_trace("empty script");
		L_frame_push(interp, envPtr, NULL);
		L_PUSH_STR("");
		L_frame_pop();
		return (TCL_OK);
	}
	return (LCompileScript(interp, envPtr, ast, 0));
}

/*
 * Parse an L script into an AST.  Parsing and compiling are broken into two
 * stages in order to support an interactive mode that parses many times
 * before finally compiling.
 */
private int
LParseScript(
	Tcl_Interp *interp,
	CONST	char *str,
	int	numBytes,
	Ast	**L_ast)
{
	void	*lex_buffer;

	if (((Interp *)interp)->scriptFile) {
		L_source_file = Tcl_GetString(((Interp *)interp)->scriptFile);
	} else {
		L_source_file = "unknown";
	}
	L_do_includes(interp, str, numBytes);
	L_line_number = 1;
	L_token_offset = L_prev_token_len = 0;
	L_script = (char *)str;
	L_scriptLen = numBytes;
	L_start_lexer();
	lex_buffer = (void *)L__scan_bytes(str, numBytes);
	/* L_trace("Parsing: %.*s", numBytes, str); */
	L_trace("parsing");
	L_errors = NULL;
	L_parse();
	if (getenv("L_DUMP_AST") && L_current_ast) {
		if (L_WALK_ERROR ==
		    L_walk_ast(L_current_ast, L_WALK_PRE, LDumpAstNodes,NULL)) {
			L_trace("Error walking AST");
		}
		fprintf(stderr, "\n");
	}
	if (L_ast == NULL) {
		L_free_ast(L_current_ast);
	} else {
		*L_ast = L_current_ast;
	}
	L__delete_buffer(lex_buffer);
	if (L_errors) {
		Tcl_SetObjResult(interp, L_errors);
		L_trace("Failed to parse.");
		return (TCL_ERROR);
	}
	L_trace("Done parsing.");
	return (TCL_OK);
}


/* Compile an L AST into Tcl ByteCodes.  The envPtr may be NULL. */
private int
LCompileScript(
	Tcl_Interp *interp,
	CompileEnv *envPtr,
	void	*ast,
	int	opts)
{
	int	result = TCL_OK;

	L_trace("compiling");
	L_frame_push(interp, envPtr, ast);
	lframe->options = opts;
	if (envPtr) lframe->originalCodeNext = envPtr->codeNext;

	switch(((Ast*)ast)->type) {
	    case L_NODE_TOPLEVEL:
		result = L_compile_toplevels(ast);
		break;
	    default:
		L_bomb("LCompileScript error, expecting a toplevel statement, "
		    "got: %s", L_node_type_tostr[((Ast*)ast)->type]);
	}
	if (envPtr) maybeFixupEmptyCode(lframe);
	L_frame_pop();
	L_finish_typechecks();
	/*     L_free_ast(ast); */
	if (L_errors) {
		Tcl_SetObjResult(interp, L_errors);
		L_trace("Failed to compile.");
		return (TCL_ERROR);
	}
	L_trace("Done compiling");
	return (result);
}

private int
L_compile_toplevels(L_toplevel *stmt)
{
	L_toplevel *s;
	char	*name;
	Proc	*toplevelProcPtr;
	int	has_toplevel = 0;

	/* first compile the declarations */
	for (s = stmt; s; s = s->next) {
		switch (s->kind) {
		    case L_TOPLEVEL_FUN:
			L_compile_function_decl(s->u.fun);
			break;
		    case L_TOPLEVEL_TYPE:
			L_compile_struct_decl(s->u.type);
			break;
		    case L_TOPLEVEL_TYPEDEF:
			/* ignore -- handled at parse time */
			break;
		    case L_TOPLEVEL_GLOBAL:
			L_compile_global_decls(s->u.global);
			/* The initalizers of the globals are toplevel code. */
			has_toplevel = 1;
			break;
		    case L_TOPLEVEL_STMT:
			has_toplevel = 1;
			/* handled below */
			break;
		    case L_TOPLEVEL_INC:
			/* handled by L_do_includes() at parse time */
			break;
		    default:
			L_bomb("Unexpected toplevel statement type %d",
			    s->kind);
		}
	}
	if (has_toplevel == 0) return (TCL_OK);
	/* Now compile the toplevel code.  It all goes into a Tcl proc that we
	   call as soon as we're done building it. */
	name = gensym("%%l_toplevel");
	toplevelProcPtr = Begin_Proc();
	/* Mark the frame so that we can treat things specially */
	lframe->toplevel_p = TRUE;
	for (s = stmt; s; s = s->next) {
		switch (s->kind) {
		    case L_TOPLEVEL_STMT:
			L_compile_stmts(s->u.stmt);
			break;
		    case L_TOPLEVEL_GLOBAL:
			L_compile_var_decls(s->u.global);
			break;
		    default:
			break;
		}
	}

	L_return(FALSE);
	Finish_Proc(toplevelProcPtr, name);
	if (L_errors == NULL) {
	    /* This actually invokes the toplevel code that we just compiled */
		if (lframe->envPtr) {
			L_PUSH_STR(name);
			L_INVOKE(1);
		} else {
			return (Tcl_Eval(lframe->interp, name));
		}
	}
	return (TCL_OK);
}

private int
L_compile_include(Tcl_Interp *interp, const char *file)
{
	L_compile_frame *_lframe = lframe;
	Tcl_Obj	*_L_errors = L_errors;
	int	_L_line_number = L_line_number;
	char	*_L_source_file = L_source_file;
	void	*_L_current_ast = L_current_ast;
	char	*_L_script = L_script;
	int	_L_scriptLen = L_scriptLen;
	int	_L_token_offset = L_token_offset;
	int	_L_prev_token_len = L_prev_token_len;
	Tcl_Obj	*o = Tcl_NewStringObj(file, strlen(file));
	int	retval;

	L_trace("including %s\n", file);
	Tcl_IncrRefCount(o);
	retval = Tcl_FSEvalFile(interp, o);
	Tcl_DecrRefCount(o);
	lframe = _lframe;
	L_errors = _L_errors;
	L_line_number = _L_line_number;
	L_source_file = _L_source_file;
	L_current_ast = _L_current_ast;
	L_script = _L_script;
	L_scriptLen = _L_scriptLen;
	L_token_offset = _L_token_offset;
	L_prev_token_len = _L_prev_token_len;

	return (retval);
}

private void
L_compile_function_decl(L_function_decl *fun)
{
	Proc	*procPtr;

	unless (fun) return;
	L_trace("compiling function %s", fun->name->u.string);
	L_store_fun_type(fun);
	procPtr = Begin_Proc();
	lframe->block = (Ast *)fun;
	L_compile_parameters(fun->params);
	L_enclosing_func = fun;
	L_compile_block(fun->body);
	L_enclosing_func = NULL;

	/* This is the "fall off the end" implicit return. We return "". */
	L_return(FALSE);

	Finish_Proc(procPtr, fun->name->u.string);
}

private Proc *
Begin_Proc(void)
{
	Proc *procPtr;
	CompileEnv *envPtr;
	char *scriptCopy;

	envPtr = (CompileEnv *)ckalloc(sizeof(CompileEnv));
	L_frame_push(lframe->interp, envPtr, NULL);

	scriptCopy = ckalloc(L_scriptLen + 1);
	strncpy(scriptCopy, L_script, L_scriptLen);
	*(scriptCopy + L_scriptLen) = '\0';

	procPtr = (Proc *)ckalloc(sizeof(Proc));
	procPtr->iPtr = (struct Interp *)lframe->interp;
	procPtr->refCount = 1;
	procPtr->bodyPtr = Tcl_NewObj();
	Tcl_IncrRefCount(procPtr->bodyPtr);
	procPtr->numArgs  = 0;
	procPtr->numCompiledLocals = 0;
	procPtr->firstLocalPtr = NULL;
	procPtr->lastLocalPtr = NULL;
	TclInitCompileEnv(lframe->interp, envPtr, scriptCopy, L_scriptLen,
	    NULL, 0);
	lframe->originalCodeNext = envPtr->codeNext;
	envPtr->procPtr = procPtr;

	return (procPtr);
}

private void
Finish_Proc(
	Proc	*procPtr,
	char	*name)
{
	Tcl_Obj *bodyObjPtr;
	Tcl_Command cmd;

	TclInitByteCodeObj(procPtr->bodyPtr, lframe->envPtr);
	bodyObjPtr = TclNewProcBodyObj(procPtr);
	if (bodyObjPtr == NULL) {
		L_bomb("failed to create a ProcBodyObj for some reason");
	}
	Tcl_IncrRefCount(bodyObjPtr);
#ifdef TCL_COMPILE_DEBUG
	if (getenv("L_DISASSEMBLE")) {
		printf("Bytecode for %s:\n", name);
		TclPrintByteCodeObj(lframe->interp, procPtr->bodyPtr);
	}
#endif
	cmd = Tcl_CreateObjCommand(lframe->interp, name, TclObjInterpProc,
	    (ClientData) procPtr, TclProcDeleteProc);
	procPtr->cmdPtr = (Command *) cmd;
	TclFreeCompileEnv(lframe->envPtr);
	ckfree((char *)lframe->envPtr);
	L_frame_pop();
}

private void
L_compile_struct_decl(L_type *decl)
{
	Tcl_HashEntry *hPtr;
	int	freshp;

	if (L_struct_types == NULL) {
		L_struct_types =
		    (Tcl_HashTable *)ckalloc(sizeof(Tcl_HashTable));
		Tcl_InitHashTable(L_struct_types, TCL_STRING_KEYS);
	}
	if (!decl->struct_tag ||
	    !(decl->struct_tag->kind == L_EXPR_STRING)) {
		L_errorf(decl, "Untagged struct types are not supported yet");
		return;
	}
	hPtr = Tcl_CreateHashEntry(L_struct_types, decl->struct_tag->u.string,
	    &freshp);
	Tcl_SetHashValue(hPtr, decl);
	L_trace("Declared struct type %s", decl->struct_tag->u.string);
}

private void
L_compile_global_decls(L_var_decl *decl)
{
	L_symbol *symbol;

	for (; decl; decl = decl->next) {
		symbol = L_make_symbol(decl->name, decl->type, -1);
		symbol->global_p = TRUE;
	}
}

/*
 * Initialize the struct types table and lookup a type in it.  Returns the
 * type, or NULL if none was found.
 */
private L_type *
lookup_struct_type(char *tag)
{
	Tcl_HashEntry *hPtr = NULL;

	if (L_struct_types == NULL) {
		L_struct_types =
		    (Tcl_HashTable *)ckalloc(sizeof(Tcl_HashTable));
		Tcl_InitHashTable(L_struct_types, TCL_STRING_KEYS);
	}
	hPtr = Tcl_FindHashEntry(L_struct_types, tag);

	if (hPtr) {
		return ((L_type *)Tcl_GetHashValue(hPtr));
	} else {
		return (NULL);
    }
}

/* stackeffect 0 */
private void
L_compile_var_decls(L_var_decl *var)
{
	L_symbol *symbol;

	unless (var) return;
	L_trace("declaring variable %s", var->name->u.string);

	if ((symbol = L_get_symbol(var->name, FALSE)) &&
	    !global_symbol_p(symbol)) {
		L_errorf(var, "Illegal redeclaration of local variable %s",
		    var->name->u.string);
	}

	if (var->extern_p) {
		L_compile_frame *old_frame = lframe;
		L_symbol *symbol;
		L_trace("Extern var %s", var->name->u.string);
		/* stuff the extern in the uppermost symbol table as
		   if we'd seen a global declaration for it */
		unless (symbol = L_get_local_symbol(var->name, FALSE)) {
			while (lframe->prevFrame) lframe = lframe->prevFrame;
			symbol = L_make_symbol(var->name, var->type, -1);
			symbol->global_p = TRUE;
			lframe = old_frame;
		}
	} else {
		/* if the variable isn't extern, then we must create
		   it, so we emit code to initialize it */
		int	startOffset = CurrentOffset(lframe->envPtr);
		if (lframe->toplevel_p) {
			symbol = L_get_local_symbol(var->name, FALSE);
			unless (symbol) {
				L_bomb("assertion failed, "
				    "global variable not declared");
			}
		} else {
			int localIndex;
			localIndex = TclFindCompiledLocal(var->name->u.string,
			    strlen(var->name->u.string),
			    1, lframe->envPtr->procPtr);
			symbol =
			    L_make_symbol(var->name, var->type, localIndex);
		}
		if (var->initial_value) {
			compile_initializer(var->initial_value, var->type);
		} else {
			compile_blank_initializer(var->type);
		}
		L_STORE_SCALAR(symbol->localIndex);
		L_POP();
		track_lineInfo(startOffset, var->node.beg,
			       var->node.end - var->node.beg);
	}
	L_compile_var_decls(var->next);
}

/* Compile an initializer and stack the value: stackeffect +1 */
private void
compile_initializer(
	L_initializer *init,
	L_type *type)
{
	L_initializer *i;
	int	count;

	/*
	 * XXX: this is not finished.  We only handle a single
	 * dimension, and we don't check the field count for
	 * structs.
	 * Addtl note 4/7/08: this function will go away once we
	 * support composite constants, since array & hash
	 * initializers will then come for free. */
	switch (type->kind) {
	    case L_TYPE_STRUCT:
	    case L_TYPE_ARRAY:
		if (init->value &&
		    ((Ast *)init->value)->type == L_NODE_INITIALIZER) {
			L_PUSH_STR("::list");
			for (i = (L_initializer *)init->value, count = 0;
			     i;
			     i = i->next, count++) {
				if (i->key) {
					L_errorf(i,
					    "Keys are not allowed "
					    "in array initializers.");
				}
				L_compile_exprs(i->value, FALSE);
			}
			if ((type->kind == L_TYPE_ARRAY) &&
			    (type->array_dim->u.integer > count)) {
				int left = type->array_dim->u.integer - count;
				while (left--) {
				    switch (type->next_dim->kind) {
					case L_TYPE_INT:
						L_PUSH_STR("0");
						break;
					case L_TYPE_FLOAT:
						L_PUSH_STR("0.0");
						break;
					case L_TYPE_STRING:
						L_PUSH_OBJ(Tcl_NewObj());
						break;
					default:
						L_errorf(i,
							 "composite intializers"
							 " not yet supported");
						break;
				    }
				}
				count = type->array_dim->u.integer;
			}
			L_INVOKE(count+1);
		} else {
			L_compile_exprs(init->value, FALSE);
		}
		break;
	    case L_TYPE_HASH:
		if (init->value &&
		    ((Ast *)init->value)->type == L_NODE_INITIALIZER) {
			L_PUSH_STR("::list");
			for (i = (L_initializer *)init->value, count = 0;
			     i;
			     i = i->next, count++) {
				unless (i->key) {
					L_errorf(i,
					    "Keys are required "
					    "for hash initializers.");
				} else {
					L_compile_exprs(i->key, FALSE);
				}
				L_compile_exprs(i->next_dim->value, FALSE);
			}
			L_INVOKE((count * 2) + 1);
		} else {
			L_compile_exprs(init->value, FALSE);
		}
		break;
	    default:
		/* atomic type */
		L_compile_exprs(init->value, FALSE);
	}
}

/* Stack a suitable empty value for variable's type: stackeffect +1. */
private void
compile_blank_initializer(
	L_type *type)
{
	switch (type->kind) {
	    case L_TYPE_ARRAY:
	    case L_TYPE_STRUCT:
		L_PUSH_STR("::eval");
		L_PUSH_STR("list");
		L_INVOKE(2);
		break;
	    case L_TYPE_HASH:
		L_PUSH_STR("::eval");
		L_PUSH_STR("dict create");
		L_INVOKE(2);
		break;
		break;
	    case L_TYPE_INT:
		L_PUSH_STR("0");
		break;
	    case L_TYPE_FLOAT:
		L_PUSH_STR("0.0");
		break;
	    default:
		L_PUSH_OBJ(Tcl_NewObj());
		break;
	}
}

private void
fixup_struct_type(L_type *type)
{
	L_type	*struct_type = type;

	/* if we have a struct tag without the struct definition, lookup the
	   definition. */
	unless (struct_type->members) {
		unless (struct_type->struct_tag) {
			L_bomb("Assertion failed: a struct must either "
			    "have a tag or members");
		}
		struct_type =
		    lookup_struct_type(struct_type->struct_tag->u.string);
		unless (struct_type) {
			L_errorf(type, "Undefined structure type: %s",
			    type->struct_tag->u.string);
			return;
		}
		/*
		 * Fixup the original type so that it also has the
		 * member information.  This allows all the other code
		 * to skip the lookup.
		 */
		type->members = struct_type->members;
	}
}

private int
global_symbol_p(L_symbol *symbol)
{
	return (symbol->global_p);
}

private void
L_compile_stmts(L_stmt *stmt)
{
	int	startOffset = CurrentOffset(lframe->envPtr);

	unless (stmt) return;
	switch (stmt->kind) {
	    case L_STMT_BLOCK:
		L_frame_push(lframe->interp, lframe->envPtr, stmt);
		L_compile_block(stmt->u.block);
		L_frame_pop();
		break;
	    case L_STMT_EXPR:
		L_compile_exprs(stmt->u.expr, TRUE);
		break;
	    case L_STMT_COND:
		L_compile_if_unless(stmt->u.cond);
		break;
	    case L_STMT_LOOP:
		L_compile_loop(stmt->u.loop);
		break;
	    case L_STMT_FOREACH:
		L_compile_foreach_loop(stmt->u.foreach);
		break;
	    case L_STMT_PUSH:
		L_compile_push(stmt->u.expr);
		break;
	    case L_STMT_RETURN:
		L_trace("compiling return statement");
		unless (L_enclosing_func) {
			/* No need to bail, since tcl ignores the INST_DONE. */
			L_errorf(stmt, "Return from global scope illegal\n");
		} else if (
		    (L_enclosing_func->return_type->kind == L_TYPE_VOID) &&
		    (stmt->u.expr)) {
			L_errorf(stmt,
			    "Cannot return value from void function\n");
		} else {
			L_check_expr_type(L_enclosing_func->return_type,
			    stmt->u.expr);
		}
		if (stmt->u.expr) {
			L_trace("    with return value");
			/* compile the return value */
			L_compile_exprs(stmt->u.expr, FALSE);
		} else {
			L_trace("    without return value");
			/* Leave a NULL (an Tcl_Obj with the string
			   rep "") on the stack. */
			L_PUSH_STR("");
		}
		/* INST_RETURN_STK involves a little more magic that I
		   haven't wangled out yet... but I think it lets us
		   pass back error codes and such that could be
		   useful. --timjr 2006.3.31  */
		/* TclEmitOpcode(INST_RETURN_STK, lframe->envPtr); */
		TclEmitOpcode(INST_DONE, lframe->envPtr);
		break;
	    case L_STMT_DECL:
		L_bomb("Found L_STMT_DECL where it's not supposed to be");
		break;
	    case L_STMT_BREAK:
		L_compile_break(stmt);
		break;
	    case L_STMT_CONTINUE:
		L_compile_continue(stmt);
		break;
	    default:
		L_bomb("Malformed AST in L_compile_stmts");
	}
	switch (stmt->kind) {
		case L_STMT_BLOCK:
		case L_STMT_COND:
		case L_STMT_EXPR:
			break;
		default:
			track_lineInfo(startOffset, stmt->node.beg,
				       stmt->node.end - stmt->node.beg);
			break;
	}
	L_compile_stmts(stmt->next);
}

private void
L_compile_block(L_block *block)
{
	L_compile_var_decls(block->decls);
	L_compile_stmts(block->body);
}

private void
L_compile_parameters(L_var_decl *param)
{
	Proc	*procPtr = lframe->envPtr->procPtr;
	CompiledLocal *localPtr;
	L_expr	*name;
	int	i;
	L_var_decl *p;
	int	hasParamByName = 0;

	/* Loop through all params and create the argument list for
	   the proc. */
	for (p = param, i = 0; p; p = p->next, i++) {
		if (param_passed_by_name_p(p)) {
			/* if the parameter is pass by name, we use a
			   mangled name for it so that we can define
			   an upvar using the original name */
			name = reference_mangle(p->name->u.string);
			hasParamByName = 1;
		} else {
			name = p->name;
		}
		L_trace("Compiling parameter %d (%s)", i, name->u.string);
		/* Formal parameters are stored in local variable slots. */
		procPtr->numArgs = i + 1;
		procPtr->numCompiledLocals = i + 1;
		localPtr = (CompiledLocal *) ckalloc(sizeof(CompiledLocal) -
		    sizeof(localPtr->name) +
		    strlen(name->u.string) + 1);
		if (procPtr->firstLocalPtr == NULL) {
			procPtr->firstLocalPtr =
			    procPtr->lastLocalPtr = localPtr;
		} else {
			procPtr->lastLocalPtr->nextPtr = localPtr;
			procPtr->lastLocalPtr = localPtr;
		}
		localPtr->nextPtr = NULL;
		localPtr->nameLength = strlen(name->u.string);
		localPtr->frameIndex = i;
		localPtr->flags = VAR_ARGUMENT;
		if (p->rest_p) {
			localPtr->flags |= VAR_IS_ARGS;
			if (p->next) L_errorf(p, "Rest parameter must be last");
		}
		localPtr->resolveInfo = NULL;
		localPtr->defValuePtr = NULL;
		strcpy(localPtr->name, name->u.string);
		L_make_symbol(name, p->type, i);
	}

	/* If no parameter is passed by name we are done; otherwise emit
	 * instructions to create the upvar links */
	unless (hasParamByName) return;

	L_PUSH_CSTR("1", 1);
	for (p = param, i = 0; p; p = p->next, i++) {
		if (param_passed_by_name_p(p)) {
			L_symbol *symbol;
			int	localIndex;

			/* if the parameter is pass by name, we use a
			   mangled name for it so that we can define
			   an upvar using the original name */
			name = reference_mangle(p->name->u.string);
			symbol = L_get_symbol(name, TRUE);
			localIndex =
			    TclFindCompiledLocal(p->name->u.string,
				strlen(p->name->u.string),
				1, procPtr);
			L_make_symbol(p->name, p->type, localIndex);
			L_LOAD_SCALAR(symbol->localIndex);
			TclEmitInstInt4(INST_UPVAR, localIndex, lframe->envPtr);
		}
	}
	L_POP();
}

private int
param_passed_by_name_p(L_var_decl *p)
{
	return p->by_name;
}

private void
L_compile_expr(L_expr *expr, int discard)
{
	int	len, param_count, startOffset;
	char	*p, *name;
	L_type	*type;
	L_symbol *symbol;
	Tcl_HashEntry *hPtr;

	unless (expr) return;
	startOffset = CurrentOffset(lframe->envPtr);
	switch (expr->kind) {
	    case L_EXPR_FUNCALL:
		name = expr->a->u.string;
		L_trace("compiling a call to %s", name);
		/* Check for a built-in function. */
		if (!strcmp(name, "split")) {
			int n = L_compile_exprs(expr->b, FALSE);
			if ((n < 1) || (n > 3)) {
				L_errorf(expr, "incorrect # args for split");
			}
			TclEmitInstInt1(INST_L_SPLIT, n, lframe->envPtr);
			break;
		}
		if ((symbol = L_get_local_symbol(expr->a, FALSE))) {
			/* looks like the function name is in a variable */
			L_push_var(expr);
		} else if (looks_like_pattern_func(name, len, p)
		    && !(hPtr = Tcl_FindHashEntry(L_func_table(), name))) {
			L_expr	*newArg;

			MK_STRING_NODE(newArg, p+1,
				       expr->a->node.beg + (p+1-name),
				       expr->a->node.end);
			if ((type = L_expr_type(expr->b))
			    && (type->kind == L_TYPE_WIDGET)) {
				newArg->next = expr->b->next;
				expr->b->next = NULL;
				L_compile_exprs(expr->b, FALSE);
			} else {
				*p = '\0';
				Tcl_UtfToLower(name);
				L_PUSH_STR(name);
				newArg->next = expr->b;
				*p = '_';
			}
			expr->b = newArg;
		} else {
			L_PUSH_STR(expr->a->u.string);
		}
		param_count =
		    push_parameters(symbol ? NULL : expr->a->u.string, expr->b);
		L_INVOKE(param_count+1);
		unless (symbol) {
			L_check_arg_count(expr->a->u.string, param_count, expr);
		}
		break;
	    case L_EXPR_PRE:
	    case L_EXPR_POST:
		L_compile_incdec(expr);
		break;
	    case L_EXPR_UNARY:
		L_compile_unop(expr);
		break;
	    case L_EXPR_BINARY:
		L_trace("Binary expression");
		L_compile_binop(expr);
		break;
	    case L_EXPR_INTEGER:
	    case L_EXPR_STRING:
	    case L_EXPR_FLOTE:
		l_push_literal(expr);
		break;
	    case L_EXPR_REGEXP:
		/* for a regexp, just handle the match part */
		L_compile_exprs(expr->a, FALSE);
		break;
	    case L_EXPR_INTERPOLATED_STRING:
		L_compile_interpolated_string(expr);
		break;
	    case L_EXPR_VAR:
		L_push_var(expr);
		break;
	    default:
		L_bomb("Unknown expression type %d", expr->kind);
	}

	/* Throw away the value if requested by the caller. This is
	 * done for expressions that are statements, and in some other
	 * cases. */
	if (discard) L_POP();

	switch (expr->kind) {
	    case L_EXPR_INTEGER:
	    case L_EXPR_STRING:
	    case L_EXPR_FLOTE:
	    case L_EXPR_VAR:
	    case L_EXPR_REGEXP:
		break;
	    default:
		track_lineInfo(startOffset, expr->node.beg,
			       expr->node.end - expr->node.beg);
		break;
	}
}


private int
L_compile_exprs(L_expr *expr, int discard)
{
	int	num_exprs;

	for (num_exprs = 0; expr; expr = expr->next, ++num_exprs) {
		L_compile_expr(expr, discard);
	}
	return (num_exprs);
}

/* Push the parameters of a function call on the evaluation stack and return
   the number of parameters pushed.  This is complicated because we need to
   make arrays and hashtables be implicit references, and check for
   "-foovariable, &foo", in which case we make an L pointer for foo. */
private int
push_parameters(
	char	*funcname,	/* if non-null, used to check param types */
	L_expr	*parameters)
{
	L_expr	*p;
	int	i = 0;
	int	widget_flag = FALSE;

	/* count the parameters stack them, checking for implicit
	   references and L pointers. */
	for (i = 0, p = parameters; p; p = p->next, i++) {
		L_symbol *var = NULL;

		if (funcname) L_check_arg_type(funcname, i, p);
		if ((p->kind == L_EXPR_VAR) && !p->indices) {
			var = L_get_local_symbol(p->a, FALSE);
		}
		/* if the previous parameter was -foovariable and
		   there's an &, then we need to make an L pointer */
		if (widget_flag && (p->kind == L_EXPR_UNARY) &&
		    (p->op == T_BITAND)) {
			L_trace("making an L pointer for %s\n",
			    p->a->a->u.string);
			L_push_pointer(p->a);
		} else {
			/* compile just one parameter for its value */
			L_expr *next = p->next;
			p->next = NULL;
			L_compile_exprs(p, FALSE);
			p->next = next;
		}
		/* if we see a parameter that looks like -foovariable,
		   we set the widget flag to true so we know that the
		   next parameter might be an L pointer. */
		widget_flag = FALSE;
		if (p->kind == L_EXPR_STRING) {
			widget_flag =
			    /* has at least the minimum length */
			    (strlen(p->u.string) >= strlen("-variable")) &&
			    /* starts with '-' */
			    (p->u.string[0] == '-') &&
			    /* ends with "variable" */
			    (0 == strcmp("variable",
				p->u.string +
				(strlen(p->u.string) - strlen("variable"))));
		}
	}
	return (i);
}

private void
L_push_pointer(L_expr *lval)
{
	L_PUSH_STR("::pointer");
	L_PUSH_STR("new");
	L_PUSH_STR(lval->a->u.string);
	unless (lval->indices) {
		L_INVOKE(3);
	} else {
		L_symbol *var;

		if (lval->indices->indices) {
			L_errorf(lval,
			    "more than one index is not supported yet");
		}
		if (lval->indices->kind== L_EXPR_HASH_INDEX) {
			L_errorf(lval,
			    "hash keys are not yet supported by pointers");
		}
		unless (var = L_get_local_symbol(lval->a, TRUE)) return;
		L_compile_index(var->type, lval->indices);
		L_INVOKE(4);
	}
}

/* Push a Tcl shared literal containing the value of a constant
   literal L AST node. */
private void
l_push_literal(L_expr *expr)
{
	char	buf[128];

	switch (expr->kind) {
	    case L_EXPR_STRING:
		L_PUSH_CSTR(expr->u.string, strlen(expr->u.string));
		return;
	    case L_EXPR_INTEGER:
		snprintf(buf, 128, "%lu", expr->u.integer);
		break;
	    case L_EXPR_FLOTE:
		snprintf(buf, 128, "%f", expr->u.flote);
		break;
	    case L_EXPR_UNARY:
		if (expr->op == T_PLUS) {
			snprintf(buf, sizeof(buf), "%lu", expr->a->u.integer);
		} else if (expr->op == T_MINUS) {
			snprintf(buf, sizeof(buf), "%lu", -expr->a->u.integer);
		} else {
			L_errorf(expr, "Illegal initializer");
			return;
		}
		break;
	    default:
#if 0
		// LMXXX - what is this?
		L_bomb("l_push_literal literal can't handle "
		    "expressions of type %d\n", expr->kind);
#endif
		return;
	}
	L_PUSH_STR(buf);
}

private void
L_compile_unop(L_expr *expr)
{
	/* Voids can't be cast or used as operands to any operator . */
	if (L_expr_is_void(expr->a) || L_expr_is_void(expr->b)) {
		L_errorf(expr, "Void type illegal in cast or operator");
	}

	switch (expr->op) {
	    case T_TCL_CAST:
		if ((expr->a->kind == L_EXPR_VAR) &&
		    !expr->a->indices) {
			/* XXX: this duplicates some code from
			   L_push_var... maybe 'twould be better
			   to parameterize L_push_var? */
			L_symbol *var;
			L_expr *name = expr->a->a;
			unless (var = L_get_local_symbol(name, TRUE)) return;
			L_LOAD_SCALAR(var->localIndex);
		} else {
			/* we don't do anything special if it's not a
			   plain jane variable */
			L_compile_exprs(expr->a, FALSE);
		}
		break;
	    case T_STRING_CAST:
	    case T_WIDGET_CAST:
		/* no conversion -- it's all a string. However, we
		   might have to do something here to make the future
		   type checker happy. */
		L_compile_exprs(expr->a, FALSE);
		break;
	    case T_INT_CAST:
		L_PUSH_STR("::tcl::mathfunc::int");
		L_compile_exprs(expr->a, FALSE);
		L_INVOKE(2);
		break;
	    case T_FLOAT_CAST:
		L_PUSH_STR("::tcl::mathfunc::double");
		L_compile_exprs(expr->a, FALSE);
		L_INVOKE(2);
		break;
	    case T_HASH_CAST:
		L_compile_exprs(expr->a, FALSE);
		break;
	    case T_BANG:
		L_compile_exprs(expr->a, FALSE);
		TclEmitOpcode(INST_LNOT, lframe->envPtr);
		break;
	    case T_BITNOT:
		L_compile_exprs(expr->a, FALSE);
		TclEmitOpcode(INST_BITNOT, lframe->envPtr);
		break;
	    case T_PLUS:
		L_compile_exprs(expr->a, FALSE);
		TclEmitOpcode(INST_UPLUS, lframe->envPtr);
		break;
	    case T_MINUS:
		L_compile_exprs(expr->a, FALSE);
		TclEmitOpcode(INST_UMINUS, lframe->envPtr);
		break;
	    case T_BITAND:
		/* &, address-of operator */
		L_get_local_symbol(expr->a->a, TRUE);
		L_compile_exprs(expr->a->a, FALSE);
		break;
	    case T_DEFINED:
		L_compile_defined(expr->a);
		break;
	    default:
		L_bomb("Unknown unary operator %d", expr->op);
	}
}

private void
L_compile_binop(L_expr *expr)
{
	L_type	*type;

	/* Voids aren't legal operands to any binary operator . */
	if (L_expr_is_void(expr->a) || L_expr_is_void(expr->b)) {
		L_errorf(expr, "Void type illegal in assignment or operator");
	}

	switch (expr->op) {
	    case T_EQUALS:
		if ((type = L_expr_type(expr->a))) {
			L_check_expr_type(type, expr->b);
		}
		L_compile_assignment(expr);
		break;
	    case T_EQPLUS:
	    case T_EQMINUS:
	    case T_EQSTAR:
	    case T_EQSLASH:
	    case T_EQPERC:
	    case T_EQBITAND:
	    case T_EQBITOR:
	    case T_EQBITXOR:
	    case T_EQLSHIFT:
	    case T_EQRSHIFT:
		L_check_expr_kind(L_TYPE_NUMBER, expr->a);
		L_check_expr_kind(L_TYPE_NUMBER, expr->b);
		L_compile_assignment(expr);
		break;
	    case T_ANDAND:
	    case T_OROR:
		L_compile_short_circuit_op(expr);
		break;
	    case T_EQTWID:
		L_check_expr_kind(L_TYPE_STRING, expr->a);
		L_compile_twiddle(expr);
		break;
	    case T_EQ:
	    case T_NE:
	    case T_GT:
	    case T_GE:
	    case T_LT:
	    case T_LE:
		L_check_expr_kind(L_TYPE_STRING, expr->a);
		L_check_expr_kind(L_TYPE_STRING, expr->b);
		L_compile_exprs(expr->a, FALSE);
		L_compile_exprs(expr->b, FALSE);
		TclEmitOpcode(instruction_for_l_op(expr->op), lframe->envPtr);
		break;
	    case T_EQUALEQUAL:
	    case T_NOTEQUAL:
		L_compile_exprs(expr->a, FALSE);
		L_compile_exprs(expr->b, FALSE);
		TclEmitOpcode(instruction_for_l_op(expr->op), lframe->envPtr);
		break;
	    case T_GREATER:
	    case T_GREATEREQ:
	    case T_LESSTHAN:
	    case T_LESSTHANEQ:
	    case T_PLUS:
	    case T_MINUS:
	    case T_STAR:
	    case T_SLASH:
	    case T_PERC:
	    case T_BITAND:
	    case T_BITOR:
	    case T_BITXOR:
	    case T_LSHIFT:
	    case T_RSHIFT:
		L_check_expr_kind(L_TYPE_NUMBER, expr->a);
		L_check_expr_kind(L_TYPE_NUMBER, expr->b);
		L_compile_exprs(expr->a, FALSE);
		L_compile_exprs(expr->b, FALSE);
		TclEmitOpcode(instruction_for_l_op(expr->op), lframe->envPtr);
		break;
	    default:
		L_bomb("L_compile_binop: malformed AST");
	}
}

private void
L_compile_interpolated_string(L_expr *expr)
{
	int	count = 0;

	if ((expr->a->kind != L_EXPR_STRING)
	    || (expr->a->u.string[0] != '\0')) {
		L_compile_exprs(expr->a, FALSE);
		count++;
	}
	if ((expr->b->kind != L_EXPR_STRING)
	    || (expr->b->u.string[0] != '\0')) {
		L_compile_exprs(expr->b, FALSE);
		count++;
	}
	if (expr->c) {
		if ((expr->c->kind != L_EXPR_STRING)
		    || (expr->c->u.string[0] != '\0')) {
			L_compile_exprs(expr->c, FALSE);
			count++;
		}
	} else {
		/* Currently, an interpolated string node will always
		   be followed by another one, or by a regular string
		   node, so there's no way to test this branch.  */
		L_bomb("L_compile_interpolated_string: Malformed AST");
	}
	if (count > 1) {
		TclEmitInstInt1(INST_CONCAT1, count, lframe->envPtr);
	} else if (count == 0) {
		L_PUSH_STR("");
	}
}

private void
L_compile_twiddle(L_expr *expr)
{
	Tcl_Obj	*const_regexp = Tcl_NewObj();
	Tcl_RegExp compiled;
	L_expr	*runner, *regexp = expr->b;
	int	submatchCount = 0;
	int	rtype, i, modCount;

	if (regexp->b) {
		/* it's a substitution, so let L_compile_assignment do
		 * the hard stuff */
		L_compile_assignment(expr);
		return;
	}

	/* put together the parts of the regexp that we know at
	   compile time */
	Tcl_IncrRefCount(const_regexp);
	for (runner = regexp->a; runner; runner = runner->c) {
		switch (runner->kind) {
		    case L_EXPR_INTERPOLATED_STRING:
			Tcl_AppendToObj(const_regexp, runner->a->u.string, -1);
			/* if we ever find a spot where the regexp
			   breaks, we could try adding a space to
			   replace the runner->b interpolated part.
			   (see the XXX comment below) */
			// Tcl_AppendToObj(const_regexp, " ", 1);
			break;
		    case L_EXPR_STRING:
			Tcl_AppendToObj(const_regexp, runner->u.string, -1);
			break;
		    default:
			L_bomb("L_compile_twiddle: Malformed AST");
		}
	}
	/* now try to compile the regexp, just to figure out how many
	   submatches there are. */
	compiled = Tcl_GetRegExpFromObj(lframe->interp, const_regexp,
	    TCL_REG_ADVANCED);
	if (compiled == NULL) {
		/* XXX: does a regexp really have to be correct sans
		   interpolated parts?  If not, this error might
		   happen at the wrong time.  To support such regexps,
		   we would have to count submatches at runtime. */
		L_errorf(expr, "Bad regular expression");
	} else {
		submatchCount = ((TclRegexp *)compiled)->re.re_nsub;
	}
	L_trace("The submatch count in %s is %d\n",
	    Tcl_GetString(const_regexp), submatchCount);
	/* create the submatch variables */
	for (i = 0; i <= submatchCount; i++) {
		char	buf[128];
		L_expr	*name;
		L_symbol *s;

		snprintf(buf, 128, "$%d", i);
		MK_STRING_NODE(name, buf, 0, 0);
		unless (L_get_symbol(name, FALSE)) {
			int localIndex =
			    TclFindCompiledLocal(name->u.string,
				strlen(name->u.string), 1,
				lframe->envPtr->procPtr);
			s = L_make_symbol(name, mk_type(L_TYPE_STRING, NULL,
			    NULL, NULL, NULL, FALSE, 0, 0), localIndex);
			s->used_p = TRUE;     /* suppress unused var warning */
		}
	}

	/*
	 * Check if the regexp can be compiled (like Tcl's)
	 */
	REGEXP_TYPE(regexp, rtype);
	if  (!submatchCount && rtype) {
		/*
		 * Can compile it: no match vars, no options (or just -nocase )
		 */
		int	simple = 0, exact = 0, nocase;

		nocase = (rtype == 'i');

		if (regexp->a->kind == L_EXPR_STRING) {
			Tcl_DString ds;
			int	len;

			/*
			 * Attempt to convert pattern to glob.  If
			 * successful, push the converted pattern as a
			 * literal.
			 */
			len = strlen(regexp->a->u.string);
			if (TclReToGlob(NULL, regexp->a->u.string, len,
			    &ds, &exact) == TCL_OK) {
				simple = 1;
				L_PUSH_CSTR(Tcl_DStringValue(&ds),
				    Tcl_DStringLength(&ds));
				Tcl_DStringFree(&ds);
			}
		}
		unless (simple) L_compile_exprs(regexp->a, FALSE);
		/* the target string */
		L_compile_exprs(expr->a, FALSE);
		if (simple) {
			if (exact && !nocase) {
				TclEmitOpcode(INST_STR_EQ, lframe->envPtr);
			} else {
				TclEmitInstInt1(INST_STR_MATCH, nocase,
				    lframe->envPtr);
			}
		} else {
			TclEmitInstInt1(INST_REGEXP, nocase, lframe->envPtr);
		}
		Tcl_DecrRefCount(const_regexp);
		return;
	}
	/* emit code to call the regexp object command */
	L_PUSH_STR("::regexp");
	/* modifiers */
	modCount = push_regexp_modifiers(regexp);
	L_PUSH_STR("--");
	/* the regexp */
	L_compile_exprs(regexp, FALSE);
	/* the target string */
	L_compile_exprs(expr->a, FALSE);
	/* match/submatch vars. NB: this loop always goes around at
	   least once. */
	for (i = 0; i <= submatchCount; i++) {
		char	buf[128];
		snprintf(buf, 128, "$%d", i);

		/*
		 * You do not want THESE to be shared literals, likely
		 * to cause too much shimmering with literal numbers
		 * L_PUSH_STR(buf);
		 */

		L_PUSH_OBJ(Tcl_NewStringObj(buf, -1));
	}
	L_trace("submatch count is %d\n", submatchCount);
	L_INVOKE(5 + submatchCount + modCount);
	Tcl_DecrRefCount(const_regexp);
}

private void
L_compile_short_circuit_op(L_expr *expr)
{
	int	jumpOffset;
	unsigned char op;

	L_compile_exprs(expr->a, FALSE);
	/* In case the operator short-circuits, we need one value on
	   the evaluation stack for the jump and one for the value of
	   the expression. */
	TclEmitOpcode(INST_DUP, lframe->envPtr);
	op = (expr->op == T_ANDAND) ? INST_JUMP_FALSE4 : INST_JUMP_TRUE4;
	jumpOffset = CurrentOffset(lframe->envPtr);
	TclEmitInstInt4(op, 0, lframe->envPtr);
	/* If the operator doesn't short-circuit, we want to leave the
	   value of the second expression on the stack, so remove the
	   value that we DUPed above. */
	L_POP();
	L_compile_exprs(expr->b, FALSE);
	TclUpdateInstInt4AtPc(op, CurrentOffset(lframe->envPtr) - jumpOffset,
	    lframe->envPtr->codeStart + jumpOffset);
}

private void
L_compile_if_unless(L_if_unless *cond)
{
	/* There are two jumps: one that skips the consequent, called
	 * jumpFalse, and one called jumpEnd that skips the alternate
	 * (else) part. */
	int	jumpFalseOffset, jumpEndOffset;
	L_type	*type;

	if (L_expr_is_void(cond->condition)) {
		L_errorf(cond->condition, "Void not a legal predicate");
	}
	L_compile_exprs(cond->condition, FALSE);
	unless (EXPR_IS_VALID_BOOLEAN(cond->condition)) {
		L_PUSH_STR("0");
		TclEmitOpcode(INST_NEQ, lframe->envPtr);
	}

	/* Emit jumpFalse.  We use fixed-size jumps to simplify the code. */
	jumpFalseOffset = CurrentOffset(lframe->envPtr);
	TclEmitInstInt4(INST_JUMP_FALSE4, 0, lframe->envPtr);

	L_frame_push(lframe->interp, lframe->envPtr, cond);

	if (cond->if_body != NULL) {
		L_compile_stmts(cond->if_body);
	}

	if (cond->else_body == NULL) {
		TclUpdateInstInt4AtPc(INST_JUMP_FALSE4,
		    CurrentOffset(lframe->envPtr) - jumpFalseOffset,
		    lframe->envPtr->codeStart + jumpFalseOffset);
	} else {
		L_frame_pop();
		L_frame_push(lframe->interp, lframe->envPtr, cond);

		/* Emit jumpEnd. */
		jumpEndOffset = CurrentOffset(lframe->envPtr);
		TclEmitInstInt4(INST_JUMP4, 0, lframe->envPtr);

		/* Set the target on jumpFalse to here, so it skips
		   over jumpEnd. */
		TclUpdateInstInt4AtPc(INST_JUMP_FALSE4,
		    CurrentOffset(lframe->envPtr) - jumpFalseOffset,
		    lframe->envPtr->codeStart + jumpFalseOffset);

		L_compile_stmts(cond->else_body);

		/* Set the jumpEnd target to just after the body of
		   the else part. */
		TclUpdateInstInt4AtPc(INST_JUMP4,
		    CurrentOffset(lframe->envPtr) - jumpEndOffset,
		    lframe->envPtr->codeStart + jumpEndOffset);
	}
	L_frame_pop();
}

private void
L_compile_loop(L_loop *loop)
{
	int	jumpToCond;
	Jumps	*break_jumps, *continue_jumps;
	int	bodyCodeOffset, jumpDist, startOffset;
	L_type	*type;

	startOffset = CurrentOffset(lframe->envPtr);
	if ((loop->kind == L_LOOP_FOR) && loop->pre) {
		L_compile_exprs(loop->pre, TRUE);
	}
	/* XXX: need optimization for null conditions and infinite
	 * loops See TclCompileWhileComd() for the stuff Tcl does.
	 */
	jumpToCond = CurrentOffset(lframe->envPtr);
	TclEmitInstInt4(INST_JUMP4, 0, lframe->envPtr);
	L_frame_push(lframe->interp, lframe->envPtr, loop);
	bodyCodeOffset = CurrentOffset(lframe->envPtr);
	L_compile_stmts(loop->body);
	/* grab the jump offsets out of the frame before popping it */
	break_jumps = lframe->break_jumps;
	continue_jumps = lframe->continue_jumps;
	L_frame_pop();
	fixup_jumps(lframe->envPtr, continue_jumps,
	    CurrentOffset(lframe->envPtr));
	if ((loop->kind == L_LOOP_FOR) && loop->post) {
		L_compile_exprs(loop->post, TRUE);
	}
	TclUpdateInstInt4AtPc(INST_JUMP4,
	    CurrentOffset(lframe->envPtr) - jumpToCond,
	    lframe->envPtr->codeStart + jumpToCond);
	if (L_expr_is_void(loop->condition)) {
		L_errorf(loop->condition, "Void not a legal predicate");
	}
	L_compile_exprs(loop->condition, FALSE);
	unless (EXPR_IS_VALID_BOOLEAN(loop->condition)) {
		L_PUSH_STR("0");
		TclEmitOpcode(INST_NEQ, lframe->envPtr);
	}
	jumpDist = CurrentOffset(lframe->envPtr) - bodyCodeOffset;
	if (jumpDist > 127) {
		TclEmitInstInt4(INST_JUMP_TRUE4, -jumpDist, lframe->envPtr);
	} else {
		TclEmitInstInt1(INST_JUMP_TRUE1, -jumpDist, lframe->envPtr);
	}
	fixup_jumps(lframe->envPtr, break_jumps, CurrentOffset(lframe->envPtr));
}

/* Fix the jump target for a list of INST_JUMP4 jumps and free the
   Jumps entries. */
private void
fixup_jumps(
	CompileEnv *envPtr,		/* The envPtr that the jump is in. */
	Jumps	*jumps,			/* The list of jumps to adjust. */
	int	targetOffset)		/* The target to jump to,
					   relative to the beginning
					   of the code array. */
{
	Jumps	*j;

	for (j = jumps; j; jumps = j->next, ckfree((char *)j), j = jumps) {
		TclUpdateInstInt4AtPc(INST_JUMP4, targetOffset - j->offset,
		    envPtr->codeStart + j->offset);
	}
}

private void
L_compile_foreach_loop(L_foreach_loop *loop)
{
	L_type	*type = L_expr_type(loop->expr);

	unless (type) {
		L_errorf(loop->expr, "Unknown type of foreach expression");
		return;
	}
	switch (type->kind) {
	    case L_TYPE_ARRAY:
		L_compile_foreach_loop_array(loop);
		break;
	    case L_TYPE_HASH:
		L_compile_foreach_loop_hash(loop);
		break;
	    case L_TYPE_STRING:
		L_errorf(loop->expr,
		    "Foreach over string not yet implemented");
		break;
	    case L_TYPE_POLY:
		L_errorf(loop->expr, "Foreach over poly not yet implemented");
		break;
	    default:
		L_errorf(loop->expr, "Illegal foreach expression"
		    " (must be array, hash, string, or poly)");
		break;
	}
}

/*
 * Most of the following function came from tclCompCmds.c
 * TclCompileForEachCmd(), modified in various ways for L.
 */
private void
L_compile_foreach_loop_array(L_foreach_loop *loop)
{
	int		i, continue_off, loopctr_idx, num_vars, val_idx;
	L_expr	*var;
	L_type		*expr_type;
	ForeachInfo	*info;
	ForeachVarList	*varlist;
	unsigned char	*jumpPc;
	JumpFixup	jumpFalseFixup;
	Jumps		*break_jumps, *continue_jumps;
	int		jumpBackDist, jumpBackOffset, infoIndex;

	/*
	 * Type-check the value variables.  In "foreach (v1,v2,v3 in
	 * a)", v* are the value variables or variable list, and a is
	 * the value list, in tcl terminology.
	 */
	expr_type = L_expr_type(loop->expr);
	for (var = loop->key, num_vars = 0; var; var = var->next, ++num_vars) {
		L_symbol *s = L_get_local_symbol(var, TRUE);
		unless (s) return;
		L_check_type(s->type, expr_type->next_dim, loop->expr);
	}

	/* Temps for value list value and loop counter. */
	val_idx = TclFindCompiledLocal(NULL, 0, 1, lframe->envPtr->procPtr);
	loopctr_idx = TclFindCompiledLocal(NULL, 0, 1, lframe->envPtr->procPtr);

	/*
	 * ForeachInfo and ForeachVarList are structures required by
	 * the bytecode interpreter for foreach bytecodes.  In our
	 * case, we have only one value and one variable list
	 * consisting of num_vars variables.
	 */
	info = (ForeachInfo *)ckalloc(sizeof(ForeachInfo) +
	    sizeof(ForeachVarList *));
	info->numLists       = 1;
	info->firstValueTemp = val_idx;
	info->loopCtTemp     = loopctr_idx;
	varlist = (ForeachVarList *)ckalloc(sizeof(ForeachVarList) +
	    num_vars * sizeof(int));
	varlist->numVars = num_vars;
	for (i = 0, var = loop->key; var; var = var->next, ++i) {
		L_symbol *s = L_get_local_symbol(var, TRUE);
		varlist->varIndexes[i] = s->localIndex;
	}
	info->varLists[0] = varlist;
	infoIndex = TclCreateAuxData(info, &tclForeachInfoType, lframe->envPtr);

	/* Evaluate the values to iterate through, and assign to the
	   value temp. */
	L_compile_exprs(loop->expr, FALSE);
	L_STORE_SCALAR(val_idx);
	L_POP();

	/* Initialize the loop state. */
	TclEmitInstInt4(INST_FOREACH_START4, infoIndex, lframe->envPtr);

	/* Top of the loop.  Step, and jump out if done. */
	continue_off = CurrentOffset(lframe->envPtr);
	TclEmitInstInt4(INST_FOREACH_STEP4, infoIndex, lframe->envPtr);
	TclEmitForwardJump(lframe->envPtr, TCL_FALSE_JUMP, &jumpFalseFixup);

	/* Loop body. */
	L_frame_push(lframe->interp, lframe->envPtr, loop);
	L_compile_stmts(loop->body);
	break_jumps    = lframe->break_jumps;
	continue_jumps = lframe->continue_jumps;
	L_frame_pop();
	fixup_jumps(lframe->envPtr,
	    continue_jumps, CurrentOffset(lframe->envPtr));

	/* End of loop -- jump back to top. */
	jumpBackOffset = CurrentOffset(lframe->envPtr);
	jumpBackDist   = jumpBackOffset - continue_off;
	if (jumpBackDist > 120) {
		TclEmitInstInt4(INST_JUMP4, -jumpBackDist, lframe->envPtr);
	} else {
		TclEmitInstInt1(INST_JUMP1, -jumpBackDist, lframe->envPtr);
	}

	/* Fixup jumps. */
	if (TclFixupForwardJumpToHere(lframe->envPtr, &jumpFalseFixup, 127)) {
		/* Update the jump back to the loop top since it also
		   moved down. */
		jumpBackOffset += 3;
		jumpPc = (lframe->envPtr->codeStart + jumpBackOffset);
		jumpBackDist += 3;
		if (jumpBackDist > 120) {
			TclUpdateInstInt4AtPc(INST_JUMP4, -jumpBackDist,jumpPc);
		} else {
			TclUpdateInstInt1AtPc(INST_JUMP1, -jumpBackDist,jumpPc);
		}
	}
	fixup_jumps(lframe->envPtr, break_jumps, CurrentOffset(lframe->envPtr));
}

private void
L_compile_foreach_loop_hash(L_foreach_loop *loop)
{
	L_symbol *keyVar, *valueVar = NULL;
	int	jumpWhenEmptyOffset, bodyTargetOffset;
	int	iteratorIndex, jumpDisplacement;
	Jumps	*break_jumps, *continue_jumps;

	unless (keyVar = L_get_local_symbol(loop->key, TRUE)) return;
	if (loop->value) {
		unless (valueVar = L_get_local_symbol(loop->value, TRUE)) {
			return;
		}
	}
	/* Ensure there is only one variable. */
	if (loop->key->next) {
		L_errorf(loop,
		    "multiple variables illegal in foreach over hash");
	}
	L_compile_exprs(loop->expr, FALSE);
	/* A temporary variable to hold the iterator state.*/
	iteratorIndex =
	    TclFindCompiledLocal(NULL, 0, 1, lframe->envPtr->procPtr);
	/* Both DICT_FIRST and DICT_NEXT leave value, key, and done-p
	   on the stack.  Check done-p and jump out of the loop if
	   it's true. (We fixup the jump target once we know the size
	   of the loop body.) */
	TclEmitInstInt4(INST_DICT_FIRST, iteratorIndex, lframe->envPtr);
	jumpWhenEmptyOffset = CurrentOffset(lframe->envPtr);
	TclEmitInstInt4(INST_JUMP_TRUE4, 0, lframe->envPtr);
	/* Update the key and value variables. We save the offset of
	   this code so we can jump back to it after DICT_NEXT. */
	bodyTargetOffset = CurrentOffset(lframe->envPtr);
	L_STORE_SCALAR(keyVar->localIndex);
	L_POP();
	if (loop->value) {
		L_STORE_SCALAR(valueVar->localIndex);
	}
	L_POP();
	L_frame_push(lframe->interp, lframe->envPtr, loop);
	L_compile_stmts(loop->body);
	/* grab the jump offsets out of the frame before popping it */
	break_jumps = lframe->break_jumps;
	continue_jumps = lframe->continue_jumps;
	L_frame_pop();
	fixup_jumps(lframe->envPtr, continue_jumps,
	    CurrentOffset(lframe->envPtr));
	TclEmitInstInt4(INST_DICT_NEXT, iteratorIndex, lframe->envPtr);
	/* If there's another entry in the hash, go around the loop
	   again. */
	jumpDisplacement = bodyTargetOffset - CurrentOffset(lframe->envPtr);
	TclEmitInstInt4(INST_JUMP_FALSE4, jumpDisplacement, lframe->envPtr);
	/* This is the end of the loop.  Point the jump after the
	   DICT_FIRST to here. */
	jumpDisplacement = CurrentOffset(lframe->envPtr) - jumpWhenEmptyOffset;
	TclUpdateInstInt4AtPc(INST_JUMP_TRUE4, jumpDisplacement,
	    lframe->envPtr->codeStart + jumpWhenEmptyOffset);
	/* All done.  Cleanup the bogus values that
	   DICT_FIRST/DICT_NEXT pushed and emit DICT_DONE. */
	L_POP();
	L_POP();
	fixup_jumps(lframe->envPtr, break_jumps, CurrentOffset(lframe->envPtr));
	/* XXX We need to ensure that DICT_DONE happens in the face of
	   exceptions, so that the refcount on the dict will be
	   decremented, and the iterator freed.  See the
	   implementation of "dict for" in tclCompCmds.c.  --timjr
	   2006.11.3 */
	TclEmitInstInt4(INST_DICT_DONE, iteratorIndex, lframe->envPtr);
}

private void
L_compile_push(L_expr *expr)
{
	L_symbol *symbol;

	unless (symbol = L_get_local_symbol(expr->a, TRUE)) return;

	L_PUSH_STR(expr->a->u.string);

	L_compile_exprs(expr->b, FALSE);

	if (symbol->localIndex < 0) {
		TclEmitOpcode(INST_LAPPEND_STK, lframe->envPtr);
	} else if (symbol->localIndex <= 255) {
		TclEmitInstInt1(INST_LAPPEND_SCALAR1, symbol->localIndex,
		    lframe->envPtr);
	} else {
		TclEmitInstInt4(INST_LAPPEND_SCALAR4, symbol->localIndex,
		    lframe->envPtr);
	}
	L_POP();
	L_POP();
}

/* Pushes all the indices necessary for an expression. Return value is
 * L_FIRST_IS_HASH if the first set is for a hash table, 0
 * otherwise. */
#define IS_HASH(index) ((index)->kind == L_EXPR_HASH_INDEX)

private int
L_push_set_of_indices(
	L_expr	*expr,
	L_type	*type,
	int	*depthPtr,
	Tcl_Obj	**countsPtr)
{
	L_expr	*index = expr->indices;
	int	flags, isHash, depth, levelCount;
	Tcl_Obj	*counts = Tcl_NewObj();

	unless (index) {
		Tcl_Panic("Calling L_push_set_of_indices "
		    "and no indices present");
	}

	isHash = IS_HASH(index);
	flags = (isHash? L_FIRST_IS_HASH : 0);

	depth = 0;
	levelCount = 0;
	while (1) {
		type = L_compile_index(type, index);
		depth++;
		levelCount++;
		index = index->indices;
		if (index && (IS_HASH(index) == isHash)) continue;

		/*
		 * This is the end of a level: lappend the levelCount
		 * to counts. Then return if we are done, or prepare
		 * for the next level.
		 */
		Tcl_ListObjAppendElement(NULL, counts,
		    Tcl_NewIntObj(levelCount));
		unless (index) break;
		isHash = !isHash;
		levelCount = 0;
	}

	*depthPtr = depth;
	*countsPtr = counts;
	return (flags);
}

private void
L_push_var(L_expr *expr)
{
	L_symbol *var = NULL;
	L_expr	*name = expr->a;

	unless (var = L_get_local_symbol(name, TRUE)) {
		L_PUSH_STR("");
		return;
	}
	unless (expr->indices) {
		L_LOAD_SCALAR(var->localIndex);
	} else {
		/*
		 * Compile the L deep diving code for reading
		 *
		 * FIXME: should we use direct code for
		 * lindex/dict-get when there is only one level? Only
		 * if it is much faster ...
		 */

		int	depth, flags;
		Tcl_Obj *counts;

		flags = L_push_set_of_indices(expr, var->type, &depth, &counts);

		/* store the list of counts at stacktop; pushing a
		 * literal, it will be reconverted to list rep at
		 * first use.  FIXME: check if we can store this
		 * object as literal directly!  Probably not good, it
		 * will prevent sharing.
		 */

		L_PUSH_STR(Tcl_GetString(counts));
		Tcl_DecrRefCount(counts);
		L_LOAD_SCALAR(var->localIndex);

		TclEmitInstInt4(INST_L_DEEP, depth+2, lframe->envPtr);
		TclEmitInt1(flags, lframe->envPtr);
	}
}

/* Import a global variable into a procedure's table of locals and
   create an L symbol that shadows the global one. Return the new L
   symbol. */
private L_symbol *
import_global_symbol(L_symbol *var)
{
	L_symbol *local;
	int	localIndex;
	L_expr	*name;  // eugh

	L_trace("importing global variable %s", var->name);
	/* create a new local variable that shadows the global in our
	   symbol table */
	localIndex = TclFindCompiledLocal(var->name, strlen(var->name),
	    1, lframe->envPtr->procPtr);
	MK_STRING_NODE(name, var->name, var->node->beg, var->node->end);
	local = L_make_symbol(name, var->type, localIndex);
	local->used_p = TRUE;
	/* XXX: This might be bogus.  We attempt to detect whether L
	   global variables should be true globals, or should be
	   shared with the calling proc, by checking if the current
	   variable frame pointer in interp is the same as the global
	   frame pointer.  (Sharing variables with the calling proc is
	   useful if you want to use L as an expr replacement). */
	if (((Interp *)lframe->interp)->rootFramePtr ==
	    ((Interp *)lframe->interp)->varFramePtr) {
		L_PUSH_STR("::");
		L_PUSH_STR(var->name);
		TclEmitInstInt4(INST_NSUPVAR, localIndex, lframe->envPtr);
	} else {
		L_PUSH_STR("1");
		L_PUSH_STR(var->name);
		TclEmitInstInt4(INST_UPVAR, localIndex, lframe->envPtr);
	}
	L_POP();
	return (local);
}

private void
L_return(int value_on_stack_p)
{
	unless (value_on_stack_p) {
		/* Leave a NULL (an Tcl_Obj with the string rep "") on
		   the stack. */
		L_PUSH_STR("");
	}
	/* INST_RETURN_STK involves a little more magic that I haven't
	   wangled out yet... but I think it lets us pass back error
	   codes and such that could be useful. --timjr 2006.3.31  */
	/*     TclEmitOpcode(INST_RETURN_STK, lframe->envPtr); */
	TclEmitOpcode(INST_DONE, lframe->envPtr);
}

private void
L_compile_defined(L_expr *expr)
{
	L_compile_exprs(expr, FALSE);
	TclEmitOpcode(INST_L_DEFINED, lframe->envPtr);
}

private void
L_compile_assignment(L_expr *expr)
{
	L_symbol *var;
	L_expr	*lval = expr->a;
	L_expr	*rval = expr->b;

	unless (var = L_get_local_symbol(lval->a, TRUE)) {
		L_PUSH_STR("");
		return;
	}
	L_trace("COMPILING ASSIGNMENT: %s", L_expr_tostr[lval->a->kind],
	    lval->a->u.string);
	if (lval->indices) {
		L_write_index(var, lval->indices, expr, rval, FALSE);
	} else if (expr->op == T_EQTWID) {
		L_compile_exprs(rval, FALSE);
		regsub_for_assignment(var->name, var->localIndex, rval);
	} else {
		if (expr->op != T_EQUALS) L_LOAD_SCALAR(var->localIndex);
		L_compile_exprs(rval, FALSE);
		if (expr->op != T_EQUALS) {
			TclEmitOpcode(instruction_for_l_op(expr->op),
			    lframe->envPtr);
		}
		L_STORE_SCALAR(var->localIndex);
	}
}

/* Compile an expression like "baz.bar[3][4]{"asdf"} *= 2" */
private void
L_write_index(
	L_symbol *var,		/* the lvalue */
	L_expr	*index,		/* the indices into the lvalue */
	L_expr	*expr,		/* the whole assignment expression */
	L_expr	*rval,		/* the rvalue to use. */
	int	post_incr_p)	/* whether we're doing a post-increment */
{
	int	depth, flags;
	Tcl_Obj *counts;

	/* XXX to do: special case for single dimensions */

	/* push the RHS first */
	L_compile_exprs(rval, FALSE);
	/* <rval> */

	flags = L_push_set_of_indices(expr->a, var->type, &depth, &counts);
	flags |= ((expr->op == T_EQUALS)? L_DEEP_WRITE|L_DEEP_CREATE
					: L_DEEP_WRITE);
	/* <rval idx_1 idx_2 ...> */

	/*
	 * FIXME: get llength($counts), special cases for 0 (error)
	 * and 1 (just use lset or dict set?). The length is ==1 for
	 * (hashes, arrays, arrays in structs and structs in arrays),
	 * >=2 when hashes and (structs or arrays) are both involved.
	 */

	/* store the list of counts at stacktop; pushing a literal, it
	 * will be reconverted to list rep at first use. CAREFUL:
	 * shimmering of singletons! Special string rep {foo}?  FIXME:
	 * should we use direct code for lindex/dict-get when there is
	 * only one level and it is a read?
	 */

	L_PUSH_STR(Tcl_GetString(counts)); //!! string rep of [list 1] is 1:
	//!! shimmering; should we edit to {1}?  or add a space to
	//distinguish? Could well make the single elements be the
	//normal literals! How often does this happen in Tcl?
	Tcl_DecrRefCount(counts);
	L_LOAD_SCALAR(var->localIndex);
	/* <rval idx_1 idx_2 ... counts oldval> */

	TclEmitInstInt4(INST_L_DEEP, depth+2, lframe->envPtr);
	TclEmitInt1(flags, lframe->envPtr);
	/* <rval elemPtr newVarVal> */

	/*
	 * L_DEEP may lie about the stack depth, underestimating by
	 * two: the INST_L_DEEP opcode is defined to remove all
	 * arguments and leave a result; in some cases it leaves THREE
	 * results <rval> --> <elemPtr elem rval newVarVal>.  Fix it.
	 */

	if (expr->op != T_EQUALS) lframe->envPtr->currStackDepth += 2;

	/*
	 * We have now updated the deep struct to have an unshared path to the
	 * element of interest. The stack now has (rval was already in):
	 *  <elem newVarVal>          if op==T_EQUALS
	 *  <rval elemPtr newVarVal>  otherwise
	 * Set the variable, then modify elem in-place if needed
	 */
	L_STORE_SCALAR(var->localIndex);
	L_POP();
	if (expr->op == T_EQUALS) {
		/* <elem>: nothing else to be done */
	} else {
		/* <elemPtr elem rval> */
		if (expr->op == T_EQTWID) {
			/* regexp substitution: use tempvar as
			 * regsub_for_assignment requires a var. Can
			 * reuse the same one: only used at the last
			 * stage, all indices are computed already and
			 * regsub_for_assignment takes care of
			 * avoiding conflicts within itself. */

			int	localIndex = get_single_tempvar();

			/* <elemPtr elem rval> */
			TclEmitInstInt1(INST_ROT, 1, lframe->envPtr);
			/* <elemPtr rVal elem> */

			L_STORE_SCALAR(localIndex);
			L_POP();

			/* <elemPtr rval> */
			regsub_for_assignment(SINGLE_TEMPVAR, localIndex,
			    expr->b);
			/* <elemPtr match?> */
			TclEmitInstInt1(INST_ROT, 1, lframe->envPtr);
			L_LOAD_SCALAR(localIndex);
			/* <match? elemPtr newVal> */
			TclEmitInstInt1(INST_L_DEEP_WRITE, 0, lframe->envPtr);
			L_POP();
		} else {
			/* <elemPtr elem rval> */
			TclEmitOpcode(instruction_for_l_op(expr->op),
			    lframe->envPtr);
			/* <elemPtr newVal> */
			TclEmitInstInt1(INST_L_DEEP_WRITE, post_incr_p,
			    lframe->envPtr);
		}
	}
}

/* Do a regexp substitution on lvalIndex and store the result back into
 * it. Leave a boolean indicating match success/failure on the stack top. */
private void
regsub_for_assignment(
	char	*varName,
	int	varIndex,	/* name and index of var containing subject
				 * string, and where the result will be
				 * stored */
	L_expr	*regexp)	/* the regexp, substitution, and modifiers */
{
	int	modCount;

	L_trace("regsub_for_assignment");
	L_PUSH_STR("::regsub");
	modCount = push_regexp_modifiers(regexp);
	L_PUSH_STR("-line");
	L_PUSH_STR("--");

	/* the regexp */
	TclEmitInstInt1(INST_ROT, 3+modCount, lframe->envPtr);

	/* the substitution */
	L_compile_exprs(regexp->b, FALSE);

	/* the target string: push *after* everything else has been
	 * compiled to insure that possible substitutions occur before
	 * we get the "initial value" */
	L_LOAD_SCALAR(varIndex);
	TclEmitInstInt1(INST_ROT, 1, lframe->envPtr);

	L_PUSH_STR(varName);
	L_INVOKE(modCount + 7);
}

private int
push_regexp_modifiers(L_expr *regexp)
{
	int	modCount = 0;

	if (regexp->c) {
		if (strchr(regexp->c->u.string, 'i')) {
			L_PUSH_STR("-nocase");
			modCount++;
		}
		if (strchr(regexp->c->u.string, 'g')) {
			L_PUSH_STR("-all");
			modCount++;
		}
	}
	return (modCount);
}

private int
instruction_for_l_op(int op)
{
	int	instruction = 0;

	switch (op) {
	    case T_EQ:
	    case T_EQUALEQUAL:
		instruction = INST_EQ;
		break;
	    case T_NE:
	    case T_NOTEQUAL:
		instruction = INST_NEQ;
		break;
	    case T_GT:
	    case T_GREATER:
		instruction = INST_GT;
		break;
	    case T_GE:
	    case T_GREATEREQ:
		instruction = INST_GE;
		break;
	    case T_LT:
	    case T_LESSTHAN:
		instruction = INST_LT;
		break;
	    case T_LE:
	    case T_LESSTHANEQ:
		instruction = INST_LE;
		break;
	    case T_PLUS:
	    case T_PLUSPLUS:
	    case T_EQPLUS:
		instruction = INST_ADD;
		break;
	    case T_MINUS:
	    case T_MINUSMINUS:
	    case T_EQMINUS:
		instruction = INST_SUB;
		break;
	    case T_STAR:
	    case T_EQSTAR:
		instruction = INST_MULT;
		break;
	    case T_SLASH:
	    case T_EQSLASH:
		instruction = INST_DIV;
		break;
	    case T_PERC:
	    case T_EQPERC:
		instruction = INST_MOD;
		break;
	    case T_BITAND:
	    case T_EQBITAND:
		instruction = INST_BITAND;
		break;
	    case T_BITOR:
	    case T_EQBITOR:
		instruction = INST_BITOR;
		break;
	    case T_BITXOR:
	    case T_EQBITXOR:
		instruction = INST_BITXOR;
		break;
	    case T_LSHIFT:
	    case T_EQLSHIFT:
		instruction = INST_LSHIFT;
		break;
	    case T_RSHIFT:
	    case T_EQRSHIFT:
		instruction = INST_RSHIFT;
		break;
	    default:
		L_bomb("Unable to map operator %d to an instruction", op);
	}
	return (instruction);
}

/* Emit code to push an index onto the stack and return the type to use for
   compiling the next index.  We do some minimal type checking on the way. */
private L_type *
L_compile_index(
	L_type	*index_type,	/* The type of the index. */
	L_expr	*index)		/* The index expression to compile. */
{
	L_type	*t = index_type;

	switch (index->kind) {
	    case L_EXPR_STRUCT_INDEX: {
		/* structure member */
		L_var_decl *member;
		int	memberOffset;
		char	buf[128];

		member = L_get_struct_member(t, index, &memberOffset);

		unless (member) {
			L_errorf(index, "Structure field not found, %s",
			    index->a->u.string);
			break;
		}
		snprintf(buf, 128, "%i", memberOffset);
		L_PUSH_STR(buf);
		t = member->type;
		break;
	    }
	    case L_EXPR_ARRAY_INDEX:
		/* array index */
		L_trace("Compiling an array index");
		if (t->kind != L_TYPE_ARRAY) {
			L_trace("Compiling an array index and it wasn't array");
			L_errorf(index,
			    "Index into something that's not an array");
		}
		L_check_expr_kind(L_TYPE_INT, index->a);
		L_compile_exprs(index->a, FALSE);
		t = t->next_dim ? t->next_dim :
		    mk_type(L_TYPE_POLY, NULL, NULL, NULL, NULL, FALSE, 0, 0);
		break;
	    case L_EXPR_HASH_INDEX: {
		L_type *elt_type = (L_type *)t->array_dim;
		L_trace("Spitting out a hash index\n");
		L_check_expr_type(elt_type, index->a);
		L_compile_exprs(index->a, FALSE);
		t = t->next_dim ? t->next_dim :
		    mk_type(L_TYPE_POLY, NULL, NULL, NULL, NULL, FALSE, 0, 0);
		break;
	    }
	    default:
		L_bomb("Invalid kind of index, %d", index->kind);
	}
	return (t);
}

L_var_decl *
L_get_struct_member(
	L_type	*t,
	L_expr	*index,
	int	*memberOffset)
{
	L_var_decl *member;
	char	*memberName;

	if (index->a->kind == L_EXPR_STRING) {
		memberName = index->a->u.string;
	} else {
		L_bomb("Bad struct index");
		return (L_var_decl *)NULL;
	}
	unless (t->kind == L_TYPE_STRUCT) {
		L_errorf(index, "Not a structure: %s", L_type_tostr[t->kind]);
		return (L_var_decl *)NULL;
	}
	fixup_struct_type(t);
	L_trace("membername is %s", memberName);
	for (*memberOffset = 0, member = t->members;
	     member && strcmp(member->name->u.string, memberName);
	     (*memberOffset)++, member = member->next) {
		L_trace("member is %s", member->name->u.string);
	}
	return (member);
}

private void
L_compile_incdec(L_expr *expr)
{
	L_symbol *var;
	L_expr	*lval = expr->a, *rval;

	unless (var = L_get_local_symbol(lval->a, TRUE)) return;
	if (lval->indices) {
		MK_INT_NODE(rval, 1, 0, 0);
		L_write_index(var, lval->indices, expr, rval,
		    (expr->kind == L_EXPR_POST));
	} else {
		if (expr->kind == L_EXPR_PRE) {
			TclEmitInstInt1(INST_INCR_SCALAR1_IMM, var->localIndex,
			    lframe->envPtr);
			TclEmitInt1((expr->op == T_PLUSPLUS) ? 1 : -1,
			    lframe->envPtr);
		} else {
			/* we push the value of the variable, do the
			   increment, and then pop the result of the
			   increment, leaving the old value on top. */
			L_push_var(lval);
			TclEmitInstInt1(INST_INCR_SCALAR1_IMM, var->localIndex,
			    lframe->envPtr);
			TclEmitInt1((expr->op == T_PLUSPLUS) ? 1 : -1,
			    lframe->envPtr);
			L_POP();
		}
	}
}

private void
L_compile_continue(L_stmt *stmt)
{
	Jumps	*j = (Jumps *)ckalloc(sizeof(Jumps));
	L_compile_frame *loop_frame = enclosing_loop_frame(TRUE);

	unless (loop_frame) {
		L_errorf(stmt,
		    "Continue may only be used inside loops");

		return;
	}
	j->offset = CurrentOffset(lframe->envPtr);
	TclEmitInstInt4(INST_JUMP4, 0, lframe->envPtr);
	j->next = loop_frame->continue_jumps;
	loop_frame->continue_jumps = j;
}

private void
L_compile_break(L_stmt *stmt)
{
	Jumps	*j = (Jumps *)ckalloc(sizeof(Jumps));
	L_compile_frame *loop_frame = enclosing_loop_frame(TRUE);

	unless (loop_frame) {
		L_errorf(stmt,
		    "Break may only be used inside "
		    "loops and switch statements");

		return;
	}
	j->offset = CurrentOffset(lframe->envPtr);
	TclEmitInstInt4(INST_JUMP4, 0, lframe->envPtr);
	j->next = loop_frame->break_jumps;
	loop_frame->break_jumps = j;
}


/* Walk up the compile_frame stack and return the first one that
   corresponds to a loop.  If include_switch_p is true, match switch
   frames too.  Returns NULL if no matching frames were found. */
private L_compile_frame *
enclosing_loop_frame(int include_switch_p)
{
	L_compile_frame *f = NULL;

	/* XXX we're ignoring include_switch_p because there are no switch
	   statements yet... */
	for (f = lframe; f; f = f->prevFrame) {
		if (f->block &&
		    ((((Ast *)f->block)->type == L_NODE_LOOP) ||
		     (((Ast *)f->block)->type == L_NODE_FOREACH_LOOP))) {
			break;
		}
	}
	return (f);
}

/* Create a new symbol and add it to the current symbol table */
private L_symbol *
L_make_symbol(L_expr *name, L_type *type, int localIndex)
{
	int	new;
	L_symbol *symbol = (L_symbol *)ckalloc(sizeof(L_symbol));
	Tcl_HashEntry *hPtr =
	    Tcl_CreateHashEntry(lframe->symtab, name->u.string, &new);

	unless (new) {
		L_errorf(name, "Duplicate definition of symbol %s",
		    name->u.string);
	}
	symbol->name = name->u.string;
	symbol->type = type;
	symbol->localIndex = localIndex;
	symbol->global_p = FALSE;
	symbol->used_p = FALSE;
	symbol->node = (Ast *)name;
	Tcl_SetHashValue(hPtr, symbol);
	return (symbol);
}

/* Look up a symbol in the current symbol table.  If the symbol is a
   global, import the global.  Return NULL and optionally emit an
   error if symbol is not found. */
private L_symbol *
L_get_local_symbol(L_expr *name, int error_p)
{
	L_symbol *var;

	unless (var = L_get_symbol(name, error_p)) return NULL;
	if (global_symbol_p(var)) {
		L_trace("it's a global");
		var = import_global_symbol(var);
	}
	return var;
}

/* Look up a symbol in the current symbol table, return NULL and
   optionally emit an error if not found */
L_symbol *
L_get_symbol(L_expr *name, int error_p) 
{
	Tcl_HashEntry *hPtr = NULL;
	L_compile_frame *frame;
	L_symbol *symbol;

	for (frame = lframe; !hPtr && frame; frame = frame->prevFrame) {
		hPtr = Tcl_FindHashEntry(frame->symtab, name->u.string);
	}
	if (hPtr) {
		symbol = (L_symbol *)Tcl_GetHashValue(hPtr);
		symbol->used_p = TRUE;
		return (symbol);
	} else {
		L_trace("Unable to find symbol %s", name->u.string);
		if (error_p) {
			L_errorf(name, "Undeclared variable: %s",
			    name->u.string);
		}
		return (NULL);
	}
}

/* Stick an & on the front of name and return the result as an L AST
   node. */
private L_expr *
reference_mangle(char *name)
{
	L_expr	*node;
	char	*mangled_name = ckalloc(strlen(name) + 2);

	sprintf(mangled_name, "&%s", name);
	MK_STRING_NODE(node, mangled_name, 0, 0);
	ckfree(mangled_name);
	return (node);
}

/* maybeFixupEmptyCode() doesn't fix anything up right now, because we always
   emit code for the implicit return value.  But I guess that when we start
   creating global code again, we'll want it back.  --timjr 2006.5.11 */
/**
 * In case no bytecode was emitted, emit something, because
 * otherwise we'll get an error from TclExecuteByteCode.
 */
private void
maybeFixupEmptyCode(L_compile_frame *frame)
{
	if (frame->envPtr->codeNext == frame->originalCodeNext) {
		L_PUSH_STR("");
	}
}

/* Make a new unique name.  It will be freed when the current AST is freed. */
private char *
gensym(char *name)
{
	L_expr	*node;
	char	*gensym = ckalloc(strlen(name) + TCL_INTEGER_SPACE + 1);

	sprintf(gensym, "%d%s", gensym_counter++, name);
	/* exploit the property of AST nodes that they'll free the string after
	   compilation has finished. */
	MK_STRING_NODE(node, gensym, 0, 0);
	ckfree(gensym);
	return (node->u.string);
}

/* Push and Pop the L_compile_frames. */
private void
L_frame_push(
	Tcl_Interp *interp,
	CompileEnv *envPtr,
	void	*block)		/* The AST node of the current block, or NULL
				   if none. */
{
	L_compile_frame *new_frame =
	    (L_compile_frame *)ckalloc(sizeof(L_compile_frame));

	new_frame->interp = interp;
	new_frame->envPtr = envPtr;
	new_frame->block = block;
	new_frame->symtab = (Tcl_HashTable *)ckalloc(sizeof(Tcl_HashTable));
	Tcl_InitHashTable(new_frame->symtab, TCL_STRING_KEYS);
	new_frame->continue_jumps = NULL;
	new_frame->break_jumps = NULL;
	new_frame->toplevel_p = FALSE;
	new_frame->prevFrame = lframe;
	/* inherit options from the previous frame */
	if (lframe != NULL) new_frame->options = lframe->options;
	lframe = new_frame;
}

private void
L_frame_pop(void)
{
	L_compile_frame *prev = lframe->prevFrame;
	Tcl_HashEntry *hPtr;
	Tcl_HashSearch hSearch;
	L_symbol *symbol;

	// LMXXX - what is this?
	//    if (!lframe->toplevel_p) {

	/* Check for unused variables */
	for (hPtr = Tcl_FirstHashEntry(lframe->symtab, &hSearch);
	     hPtr != NULL;
	     hPtr = Tcl_NextHashEntry(&hSearch)) {
		symbol = (L_symbol *)Tcl_GetHashValue(hPtr);
		unless (symbol->used_p) {
			L_warningf(symbol->node, "Unused variable %s",
			    symbol->name);
		}
	}

	/* free the symbol table */
	for (hPtr = Tcl_FirstHashEntry(lframe->symtab, &hSearch); hPtr != NULL;
	     hPtr = Tcl_NextHashEntry(&hSearch)) {
		ckfree(Tcl_GetHashValue(hPtr));
	}
	Tcl_DeleteHashTable(lframe->symtab);
	ckfree((char *)lframe->symtab);
	/* now free the frame itself and update the global frame pointer */
	ckfree((char *)lframe);
	lframe = prev;
}

/* Give up the ghost. */
void
L_bomb(const char *format, ...)
{
	va_list	ap;

	va_start(ap, format);
	fprintf(stderr, "L Internal Error: ");
	vfprintf(stderr, format, ap);
	va_end(ap);
	fprintf(stderr, "\n");
	exit(1);
}

/* Print L compiler debugging info. */
void
L_trace(const char *format, ...)
{
	va_list	ap;

	va_start(ap, format);
	if (getenv("LTRACE")) {
		fprintf(stderr, "***: ");
		vfprintf(stderr, format, ap);
		fprintf(stderr, "\n");
	}
	va_end(ap);
	fflush(stderr);
}

void
L_warning(char *s)
{
	unless (lframe && lframe->options & L_OPT_NOWARN) {
		/* XXX there must be a better way to emit a warning */
		fprintf(stderr, "L Warning: %s\n", s);
	}
}

void
L_warningf(void *node, const char *format, ...)
{
	va_list	ap;

	unless (lframe && lframe->options & L_OPT_NOWARN) {
		va_start(ap, format);
		if (node) {
			fprintf(stderr, "%s:%d: ", L_source_file,
			    ((Ast *)node)->line_no);
		}
		fprintf(stderr, "L Warning: ");
		vfprintf(stderr, format, ap);
		fprintf(stderr, "\n");
		va_end(ap);
	}
}

/* L_error is yyerror */
void
L_error(const char *s)
{
	unless (L_errors) {
		L_errors = Tcl_NewObj();
	}
	Tcl_AppendPrintfToObj(L_errors, "%s:%d: L Error: %s\n",
	    L_source_file, L_line_number, s);
}

/* Sometimes you feel like a char*, sometimes you don't. */
void
L_errorf(void *node, const char *format, ...)
{
	va_list ap;
	char	*buf;

	va_start(ap, format);
	/* this would be nice, but it's not exported functionality: */
	/* ObjPrintfVA(NULL, L_errors, format, ap); */
	/* GNU also has a nice memory allocating sprintf function we might be able
	   to use: */
	/* #ifdef _GNU_SOURCE */
	/*     vasprintf(&buf, format, ap); */
	/*     L_error(buf); */
	/*     free(buf); */
#define TYPICAL_ARBITRARY_CONSTANT 1024
	buf = ckalloc(TYPICAL_ARBITRARY_CONSTANT);
	vsnprintf(buf, TYPICAL_ARBITRARY_CONSTANT, format, ap);
	va_end(ap);
	unless (L_errors) {
		L_errors = Tcl_NewObj();
	}
	if (node) {
		Tcl_AppendPrintfToObj(L_errors, "%s:%d: ",
		    L_source_file, ((Ast *)node)->line_no);
	}
	Tcl_AppendPrintfToObj(L_errors, "L Error: %s\n", buf);
	ckfree(buf);
}

/* /\* */
/*  * Example of an AST dumper... needs work */
/*  *\/ */
/* int LCountNodes(void *node, void *data, int order) */
/* { */
/*     int i; */
/*     int *indent = (int *)data; */

/*     if (indent == NULL) { */
/* 	fprintf(stderr, "FOO!\n"); */
/* 	return L_WALK_ERROR; */
/*     } */
/*     if (order & L_WALK_PRE) { */
/* 	for (i = 0; i < (*indent); i++) fprintf(stderr, " "); */
/* 	fprintf(stderr, "%s: ", */
/* 	  L_node_type_tostr[((Ast *)node)->type]); */
/* 	if (((Ast *)node)->type == L_NODE_EXPR) { */
/* 	    L_expr *e = (L_expr *)node; */
/* 	    switch (e->kind) { */
/* 		case L_EXPR_STRING: */
/* 			fprintf(stderr, "%s\n", e->u.string); */
/* 			break; */
/* 		case L_EXPR_INTEGER: */
/* 			fprintf(stderr, "%d\n", e->u.integer); */
/* 			break; */
/* 		default: */
/* 			fprintf(stderr, "\n"); */
/* 			break; */
/* 	    } */
/* 	} else { */
/* 	    fprintf(stderr, "\n"); */
/* 	} */
/* 	(*indent)++; */
/*     } */
/*     if (order & L_WALK_POST) { */
/* 	(*indent)--; */
/*     } */

/*     return L_WALK_CONTINUE; */
/* } */

/* An AST walker that dumps an AST with parens around it. */
private int
LDumpAstNodes(Ast *node, void *data, int order)
{
	if (order & L_WALK_PRE) {
		fprintf(stderr, "(%s", L_node_type_tostr[node->type]);
		switch (node->type) {
		    case L_NODE_STMT:
			fprintf(stderr, " :kind %s",
			    L_stmt_tostr[((L_stmt *)node)->kind]);
			break;
		    case L_NODE_TYPE:
			fprintf(stderr, " :kind %s",
			    L_type_tostr[((L_type *)node)->kind]);
			break;
		    case L_NODE_LOOP:
			fprintf(stderr, " :kind %s",
			    L_loop_tostr[((L_loop *)node)->kind]);
			break;
		    case L_NODE_TOPLEVEL:
			fprintf(stderr, " :kind %s",
			    L_toplevel_tostr[((L_toplevel *)
							   node)->kind]);
			break;
		    case L_NODE_FUNCTION_DECL:
			break;
		    case L_NODE_VAR_DECL:
			break;
		    case L_NODE_BLOCK:
			break;
		    case L_NODE_INITIALIZER:
			break;
		    case L_NODE_EXPR: {
			    L_expr *expr = (L_expr *)node;
			    fprintf(stderr, " :kind %s",
				L_expr_tostr[expr->kind]);
			    switch (expr->kind) {
				case L_EXPR_INTEGER:
				    fprintf(stderr, " :value %ld",
					expr->u.integer);
				    break;
				case L_EXPR_STRING:
				    /* XXX if there's a double-quote
				       in the string, escape it by hand */
				    fprintf(stderr, " :value \"%s\"",
					expr->u.string);
				    break;
				case L_EXPR_FLOTE:
				    fprintf(stderr, " :value %e",
					expr->u.flote);
				    break;
				default:
				    break;
			    }
			    break;
		    }
		    case L_NODE_IF_UNLESS:
			break;
		    default:
			L_bomb("undefined node type in LDumpAstNodes");
		}
	}
	if (order & L_WALK_POST) {
		fprintf(stderr, ")\n");
	}
	return (L_WALK_CONTINUE);
}

private void
L_free_ast(Ast *ast)
{
	L_trace("Freeing L AST");
	while(ast_trace_root) {
		Ast	*node = ast_trace_root;
		ast_trace_root = ast_trace_root->_trace;
		if (node->type == L_NODE_EXPR &&
		    ((L_expr *)node)->kind == L_EXPR_STRING) {
			ckfree(((L_expr *)node)->u.string);
		}
		ckfree((char *)node);
	}
	ast_trace_root = NULL;
	/* clean up the various tables too */
	Tcl_DeleteHashTable(__L_typedef_table);
	Tcl_DeleteHashTable(__L_func_table);
	Tcl_DeleteHashTable(__L_include_table);
	ckfree((char *)__L_typedef_table);
	ckfree((char *)__L_func_table);
	ckfree((char *)__L_include_table);
	__L_typedef_table = NULL;
	__L_func_table = NULL;
	__L_include_table = NULL;
}

/* Typedefs are handled at "parse time".  When the compiler walks the AST it
   can ignore them, since the types get copied into the AST by the parser. */

/* return the typedef table.  initialize it if it hasn't been initialized
   yet. */
private Tcl_HashTable *
L_typedef_table(void)
{
	unless (__L_typedef_table) {
		__L_typedef_table =
		    (Tcl_HashTable*)ckalloc(sizeof(Tcl_HashTable));
		Tcl_InitHashTable(__L_typedef_table, TCL_STRING_KEYS);
	}
	return (__L_typedef_table);
}

L_type *
L_lookup_typedef(L_expr *name, int error_p)
{
	Tcl_HashEntry *hPtr;

	hPtr = Tcl_FindHashEntry(L_typedef_table(), name->u.string);
	if (hPtr) {
		return ((L_type *)Tcl_GetHashValue(hPtr));
	} else {
		if (error_p) {
			L_errorf(name, "Undeclared type: %s", name->u.string);
		}
		return (NULL);
	}
}

/* side effects: modifies the type so that typedef_p is true, maps name to
   type in the typedef table so that type will will be returned by
   L_lookup_typedef of name. */
void
L_store_typedef(L_expr *name, L_type *type)
{
	int	new;
	Tcl_HashEntry *hPtr;
	L_type	*t;

	hPtr = Tcl_CreateHashEntry(L_typedef_table(), name->u.string, &new);
	unless (new) {
		t = Tcl_GetHashValue(hPtr);
		unless (L_same_type(type, t)) {
			L_errorf(name, "Cannot redefine type: %s",
			    name->u.string);
		}
	} else {
		/* mark all dimensions of the type as belonging to a typedef */
		for (t = type; t; t->typedef_p = TRUE, t = t->next_dim);

		Tcl_SetHashValue(hPtr, type);
	}
}

/* Pattern functions are also handled at parse time. */
private Tcl_HashTable *
L_func_table(void)
{
	unless (__L_func_table) {
		__L_func_table = (Tcl_HashTable*)ckalloc(sizeof(Tcl_HashTable));
		Tcl_InitHashTable(__L_func_table, TCL_STRING_KEYS);
	}
	return (__L_func_table);
}

/* This function returns true if the function :name is a pattern
 * function.  In that case, the name to use when calling the function
 * is returned in :newName, and the value to use for the first
 * parameter is in :firstArg. */
int
L_lookup_pattern_func(
	char	 *name,		/* The name of the function to look up */
	L_expr	**newName,	/* The name to use (only if retval is true) */
	L_expr	**firstArg)	/* The argument part of the name */
{
	int	len;
	char	*p, buf[1024];
	Tcl_HashEntry *hPtr = NULL;

	unless (name) return (FALSE);

	if (looks_like_pattern_func(name, len, p)
	    && !(hPtr = Tcl_FindHashEntry(L_func_table(), name))) {
		/* The function being called is not a real function. */
		*p = '\0';
		snprintf(buf, sizeof(buf), "%s_*", name);
		hPtr = Tcl_FindHashEntry(L_func_table(), buf);
		*p = '_';
		if (hPtr) {
			MK_STRING_NODE(*newName, buf, 0, 0);
			MK_STRING_NODE(*firstArg, p+1, 0, 0);
			L_trace("Pattern function for %s found!", name);
			return (TRUE);
		}
	}
	L_trace("No pattern function for %s found", name);
	return (FALSE);
}

/* Stuff :name in the func table */
void
L_pattern_store_name(L_expr *name)
{
	int	new;

	L_trace("Storing pattern function named %s", name->u.string);
	Tcl_CreateHashEntry(L_func_table(), name->u.string, &new);
}

/* XXX this is basically a whacked version of EnterCmdStartData int
 * tclCompile.c. */
private void
track_lineInfo(
	int	codeOffset,	/* Where this command's bytecode starts */
	int	srcOffset,	/* Where the source of the command starts (in
				 * L_script) */
	int	len)		/* The length of the source of the command. */
{
	CmdLocation *cmdLocPtr;
	CompileEnv *envPtr = lframe->envPtr;
	int	cmdIndex = lframe->envPtr->numCommands++;

	if ((cmdIndex < 0) || (cmdIndex >= envPtr->numCommands)) {
		Tcl_Panic("track_lineInfo: bad command index %d", cmdIndex);
	}
	if (cmdIndex >= envPtr->cmdMapEnd) {
		/*
		 * Expand the command location array by allocating
		 * more storage from the heap. The currently allocated
		 * CmdLocation entries are stored from cmdMapPtr[0] up
		 * to cmdMapPtr[envPtr->cmdMapEnd] (inclusive).
		 */

		size_t currElems = envPtr->cmdMapEnd;
		size_t newElems = 2*currElems;
		size_t currBytes = currElems * sizeof(CmdLocation);
		size_t newBytes = newElems * sizeof(CmdLocation);
		CmdLocation *newPtr =
		    (CmdLocation *) ckalloc((unsigned) newBytes);

		/*
		 * Copy from old command location array to new, free
		 * old command location array if needed, and mark new
		 * array as malloced.
		 */

		memcpy(newPtr, envPtr->cmdMapPtr, currBytes);
		if (envPtr->mallocedCmdMap) ckfree((char *) envPtr->cmdMapPtr);
		envPtr->cmdMapPtr = (CmdLocation *) newPtr;
		envPtr->cmdMapEnd = newElems;
		envPtr->mallocedCmdMap = 1;
	}

	cmdLocPtr = &(envPtr->cmdMapPtr[cmdIndex]);
	cmdLocPtr->codeOffset = codeOffset;
	cmdLocPtr->srcOffset = srcOffset;
	cmdLocPtr->numSrcBytes = len;
	cmdLocPtr->numCodeBytes = CurrentOffset(envPtr) - codeOffset;

	/* The command locations have to be sorted in ascending order
	 * by codeOffset.  (Or Tcl panics in GetCmdLocEncodingSize(),
	 * if nothing else). However, when L compiles nested function
	 * calls, the outer one will get tracked second, even though
	 * it begins first.  So we walk the new CmdLocation entry back
	 * from the end until it lands where it belongs. */
	while ((cmdIndex > 0) &&
	    (envPtr->cmdMapPtr[cmdIndex-1].codeOffset >
		envPtr->cmdMapPtr[cmdIndex].codeOffset)) {
		CmdLocation cmdLoc;

		cmdLoc = envPtr->cmdMapPtr[cmdIndex];
		envPtr->cmdMapPtr[cmdIndex] = envPtr->cmdMapPtr[cmdIndex-1];
		envPtr->cmdMapPtr[cmdIndex-1] = cmdLoc;
		cmdIndex--;
	}
}

private void
L_do_includes(
	Tcl_Interp *interp,
	const	char *bytes,
	int	numBytes)
{
	Tcl_RegExp includeRe = NULL;
	Tcl_Obj *strObj = Tcl_NewStringObj(bytes, numBytes);
	Tcl_Obj *regexObj = Tcl_NewStringObj(
	     "^include\\s*\\(\\s*\"([^)\"]+)\"\\s*\\)\\s*;", -1);
	int	offset = 0;

	Tcl_IncrRefCount(regexObj);
	includeRe =
	    Tcl_GetRegExpFromObj(interp, regexObj,
		TCL_REG_ADVANCED | TCL_REG_NLANCH);
	Tcl_DecrRefCount(regexObj);
	Tcl_IncrRefCount(strObj);
	while (Tcl_RegExpExecObj(interp, includeRe, strObj, offset, 2, 0)) {
		const	char *start, *end;
		char	*file, *tmp;

		/* grab the first submatch -- the include file */
		Tcl_RegExpRange(includeRe, 1, &start, &end);

		/* search the include path */
		tmp = ckstrndup(start+offset, end - start);
		file = L_include_search(interp, tmp);
		ckfree(tmp);

		/* only include each file once */
		if (fresh_include_p(interp, file)) {
			if (L_compile_include(interp, file) != TCL_OK) {
				L_warningf(NULL,
				    "Unable to include file %s: \n%s", file,
				    Tcl_GetStringResult(interp));
			}
		}
		ckfree(file);

		/* advance the starting offset by the length of the
		   complete match */
		Tcl_RegExpRange(includeRe, 0, &start, &end);
		offset += end - start;
	}
	Tcl_DecrRefCount(strObj);
}

/* Search for file in the include path.  Currently only looks in the directory
 * of the current script (i.e., dirname of [info script]).  Only call this
 * with a relative path! */
private char *
L_include_search(Tcl_Interp *interp, const char *file)
{
	char	*resolvedFile;
	Interp	*iPtr = (Interp *)interp;
	Tcl_Obj *fileObj = Tcl_NewStringObj(file, -1);

	/* if the path is relative, make it absolute */
	Tcl_IncrRefCount(fileObj);
	if (Tcl_FSGetPathType(fileObj) == TCL_PATH_ABSOLUTE ||
	    !iPtr->scriptFile) {
		resolvedFile = ckstrdup(file);
	} else {
		Tcl_Obj *scriptDir =
		    TclPathPart(interp, iPtr->scriptFile, TCL_PATH_DIRNAME);
		Tcl_AppendPrintfToObj(scriptDir, "/%s", file);
		resolvedFile = ckstrdup(Tcl_GetString(scriptDir));
	}
	Tcl_DecrRefCount(fileObj);
	return (resolvedFile);
}

/* Return true if a file has never been included before */
private int
fresh_include_p(Tcl_Interp *interp, const char *file)
{
	int	new;
	char	*normalizedPath;
	Tcl_Obj	*pathPtr;
	Tcl_HashEntry *hPtr;

	/* get a canonical path for the file */
	pathPtr = Tcl_NewStringObj(file, -1);
	Tcl_IncrRefCount(pathPtr);
	if ((pathPtr = Tcl_FSGetNormalizedPath(NULL, pathPtr)) == NULL) {
		L_errorf(NULL, "Unable to normalize include file %s\n", file);
		return (TRUE);
	}
	normalizedPath = Tcl_GetString(pathPtr);

	/* check if it's already been included */
	hPtr = Tcl_CreateHashEntry(L_include_table(), normalizedPath, &new);
	unless (new) L_trace("file %s already included", normalizedPath);
	Tcl_DecrRefCount(pathPtr);
	return (new);
}

/* return the include table.  initialize it if it hasn't been
   initialized yet. */
private Tcl_HashTable *
L_include_table(void)
{
	unless (__L_include_table) {
		__L_include_table =
		    (Tcl_HashTable*)ckalloc(sizeof(Tcl_HashTable));
		Tcl_InitHashTable(__L_include_table, TCL_STRING_KEYS);
	}
	return (__L_include_table);
}

char *
ckstrdup(const char *str)
{
	return (ckstrndup(str, strlen(str)));
}

char *
ckstrndup(const char *str, int len)
{
	char	*newStr = ckalloc(len+1);

	strncpy(newStr, str, len);
	newStr[len] = '\0';
	return (newStr);
}

/*
 * This function is based on TclLindexFlat and is specialized for use
 * by the L deep-dive execution engine.  It returns a pointer to the
 * list element Tcl_Obj* referenced by the index, and returns NULL if
 * the index is out of range (TclLindexFlat returns a pointer to an
 * empty object).
 */
private Tcl_Obj **
L_LindexFlat(
    Tcl_Interp *interp,		/* Tcl interpreter. */
    Tcl_Obj *listPtr,		/* Tcl object representing the list. */
    int indexCount,		/* Count of indices. */
    Tcl_Obj *const indexArray[])/* Array of pointers to Tcl objects that
				 * represent the indices in the list. */
{
	int	i, index, listLen;
	Tcl_Obj	**elemPtrs;

	Tcl_IncrRefCount(listPtr);
	for (i=0 ; i<indexCount && listPtr ; i++) {
		if (TclGetIntFromObj(NULL, indexArray[i], &index) != TCL_OK) {
			Tcl_DecrRefCount(listPtr);
			return NULL;
		}
		TclListObjGetElements(NULL, listPtr, &listLen, &elemPtrs);
		if (index<0 || index>=listLen) {
			/* Index is out of range. */
			Tcl_DecrRefCount(listPtr);
			return NULL;
		} else {
			/* Extract the pointer to the appropriate element. */
			Tcl_DecrRefCount(listPtr);
			listPtr = elemPtrs[index];
			Tcl_IncrRefCount(listPtr);
		}
	}
	return (&elemPtrs[index]);
}

/*
 * This function is based on TclLsetFlat and is specialized for use by
 * the L deep-dive execution engine.  It returns a pointer to the list
 * element Tcl_Obj* referenced by the index, allowing it to be written
 * in place.  Unlike TclLsetFlat, it does not write to the element.
 * Also, any list in the dive that is shorter than the given index is
 * auto-extended up to the index value.
 */
private Tcl_Obj **
L_LsetFlatExtend(
    Tcl_Interp *interp,		/* Tcl interpreter. */
    Tcl_Obj *listPtr,		/* Pointer to the list being modified. */
    int indexCount,		/* Number of index args. */
    Tcl_Obj *const indexArray[])
				/* Index args. */
{
    int elemCount, i, index, result;
    int panic = 0;
    Tcl_Obj *parentList = NULL, *subListPtr, *chainPtr, **elemPtrs;

    /*
     * Error if there are no indices.
     */

    unless (indexCount) {
	L_bomb("L deep-dive internal error");
    }

    /*
     * If the list is shared, make a copy we can modify (copy-on-write).
     * We use Tcl_DuplicateObj() instead of TclListObjCopy() for a few
     * reasons: 1) we have not yet confirmed listPtr is actually a list;
     * 2) We make a verbatim copy of any existing string rep, and when
     * we combine that with the delayed invalidation of string reps of
     * modified Tcl_Obj's implemented below, the outcome is that any
     * error condition that causes this routine to return NULL, will
     * leave the string rep of listPtr and all elements to be unchanged.
     */

    subListPtr = Tcl_IsShared(listPtr) ? Tcl_DuplicateObj(listPtr) : listPtr;

    /*
     * Anchor the linked list of Tcl_Obj's whose string reps must be
     * invalidated if the operation succeeds.
     */

    chainPtr = NULL;

    /*
     * Loop through all the index arguments, and for each one dive
     * into the appropriate sublist.
     */

    do {
	/* Check for the possible error conditions... */
	result = TCL_ERROR;
	if (TclListObjGetElements(interp, subListPtr, &elemCount, &elemPtrs)
		!= TCL_OK) {
	    /* ...the sublist we're indexing into isn't a list at all. */
	    panic = 1;
	    break;
	}

	/*
	 * WARNING: the macro TclGetIntForIndexM is not safe for
	 * post-increments, avoid '*indexArray++' here.
	 */

	if (TclGetIntForIndexM(interp, *indexArray, elemCount - 1, &index)
		!= TCL_OK)  {
	    /* ...the index we're trying to use isn't an index at all. */
	    indexArray++;
	    panic = 1;
	    break;
	}
	indexArray++;

	if (index < 0) {
	    panic = 0;
	    break;
	}
	if (index >= elemCount) {
	    /* Auto extend. */
	    Tcl_Obj **pad;
	    int n = index - elemCount + 1;
	    pad = (Tcl_Obj **)ckalloc(n * sizeof(Tcl_Obj *));
	    for (i = 0; i < n; ++i) {
		    pad[i] = Tcl_DuplicateObj(*get_undef_obj());
	    }
	    result = Tcl_ListObjReplace(interp, subListPtr,
					elemCount, 0, n, pad);
	    ckfree((char *)pad);
	    if (result != TCL_OK) {
		panic = 1;
		break;
	    }
	    result = TclListObjGetElements(interp, subListPtr, &elemCount,
					   &elemPtrs);
	    if (result != TCL_OK) {
		panic = 1;
		break;
	    }
	}

	/*
	 * No error conditions. Determine the next sublist for the
	 * next pass through the loop, and take steps to make sure it
	 * is an unshared copy, as we intend to modify it.
	 */

	result = TCL_OK;
	--indexCount;
	parentList = subListPtr;
	subListPtr = elemPtrs[index];
	if (Tcl_IsShared(subListPtr)) {
		subListPtr = Tcl_DuplicateObj(subListPtr);
	}

	/*
	 * Replace the original elemPtr[index] in parentList with a copy
	 * we know to be unshared.  This call will also deal with the
	 * situation where parentList shares its intrep with other
	 * Tcl_Obj's.  Dealing with the shared intrep case can cause
	 * subListPtr to become shared again, so detect that case and
	 * make and store another copy.
	 */

	TclListObjSetElement(NULL, parentList, index, subListPtr);
	if (Tcl_IsShared(subListPtr)) {
		subListPtr = Tcl_DuplicateObj(subListPtr);
		TclListObjSetElement(NULL, parentList, index, subListPtr);
	}

	/*
	 * The TclListObjSetElement() calls do not spoil the string
	 * rep of parentList, and that's fine for now, since all we've
	 * done so far is replace a list element with an unshared copy.
	 * The list value remains the same, so the string rep. is still
	 * valid, and unchanged, which is good because if this whole
	 * routine returns NULL, we'd like to leave no change to the
	 * value of the lset variable.  Later on, when we set valuePtr
	 * in its proper place, then all containing lists will have
	 * their values changed, and will need their string reps spoiled.
	 * We maintain a list of all those Tcl_Obj's (via a little intrep
	 * surgery) so we can spoil them at that time.
	 */

	parentList->internalRep.twoPtrValue.ptr2 = (void *) chainPtr;
	chainPtr = parentList;
    } while (indexCount > 0);

    /*
     * Either we've detected and error condition, and exited the loop
     * with result == TCL_ERROR, or we've successfully reached the last
     * index, and we're ready to store valuePtr.  In either case, we
     * need to clean up our string spoiling list of Tcl_Obj's.
     */

    while (chainPtr) {
	Tcl_Obj *objPtr = chainPtr;

	if (result == TCL_OK) {

	    /*
	     * We're going to store valuePtr, so spoil string reps
	     * of all containing lists.
	     */

	    Tcl_InvalidateStringRep(objPtr);
	}

	/* Clear away our intrep surgery mess */
	chainPtr = (Tcl_Obj *) objPtr->internalRep.twoPtrValue.ptr2;
	objPtr->internalRep.twoPtrValue.ptr2 = NULL;
    }

    /*
     * We're bailing out either because of an internal error (bug), or
     * because of a negative array index.  Panic on the former, return
     * NULL on the latter.
     */
    if (result != TCL_OK) {
	if (panic) {
	    L_bomb("L deep-dive internal error");
	}
	return NULL;
    }

    if (TclListObjGetElements(interp, parentList, &elemCount, &elemPtrs)
		!= TCL_OK) {
	return NULL;
    }
    return (&elemPtrs[index]);
}

/*
 * L_DeepDiveIntoStruct is adapted from TclLSetFlat, DictObjGet and friends.
 *
 * It returns a Tcl_Obj of LdeepPtrType (careful, VERY special handling
 * required!) with reference count 1. The internal rep is a pointer to the
 * location of the element within the deep structure.
 *
 * If L_DEEP_WRITE is passed in the flags, the path to the element is
 * guaranteed to be unshared, and all string reps in the path will be
 * invalidated. If L_DEEP_CREATE is also passed, the path will be created if
 * necessary and an empty obj will be stored at the element.
 */
 
Tcl_Obj **
L_DeepDiveIntoStruct(
	Tcl_Interp *interp,
	Tcl_Obj *valuePtr,    /* pointer to the nested struct to dive into; any
			       * modifications will be written in place */
	Tcl_Obj **idxPtr,     /* the array of indices */
	Tcl_Obj *countPtr,    /* a list of counts for each level - a level being
			       * a contiguous set of indices of same kind
			       * (ie: hash indices or list indices). */
	int	flags)        /* flag bits are L_FIRST_IS_HASH, L_DEEP_WRITE and
			       * L_DEEP_CREATE*/
{
	int	typeIsHash = (flags & L_FIRST_IS_HASH);
	int	result, numLevels, i;
	Tcl_Obj **levelCountPtr, *currValuePtr = valuePtr;
	Tcl_Obj **resultPtrPtr = NULL, *lastPtr;
	int	create = (flags & L_DEEP_CREATE);
	int	write = (flags & L_DEEP_WRITE);

	/*
	 * TODO:
	 *   - special case for just 1 level? Standard dict and list commands
	 *     handle this. Note that the dict opcode for dict-set requires a
	 *     var!
	 *     Do we want to insist on deep-diving only into vars, or are
	 *     values fair game too?
	 *   - make sure (in the compiler) that struct offsets are always
	 *     literals.
	 */
	if (write && (valuePtr->refCount != 1)) {
		Tcl_Panic(
		    "L_DeepDiveIntoStruct called for writing on an "
		    "obj with refCount = %i != 1!", valuePtr->refCount);
	}

	if ((countPtr->typePtr != &tclListType) &&
	    (TCL_OK == TclGetIntFromObj(NULL, countPtr, &i))) {
		/* NOTE: when countPtr is a singleton, avoid causing unwanted
		 * shimmering between dict and number! Special case it.
		 */

		numLevels = 1;
		levelCountPtr = &countPtr;
	} else {
		if (Tcl_IsShared(countPtr)) {
			/*
			 * Make a copy to prevent the intrep to
			 * shimmer away from us.
			 */
			countPtr = TclListObjCopy(interp, countPtr);
			unless (countPtr) return (NULL);
		}
		result = Tcl_ListObjGetElements(interp, countPtr,
		    &numLevels, &levelCountPtr);
		if (result != TCL_OK) return (NULL);
		unless (numLevels) return (NULL);
	}
	Tcl_IncrRefCount(countPtr);

	for (i = 0; i < numLevels; i++) {
		int	idxCount;

		result = Tcl_GetIntFromObj(interp, *levelCountPtr, &idxCount);
		if (result != TCL_OK) goto done;

		if (typeIsHash) {
			/*
			 * Essentially, DictObjGet/DictObjSet.  Loop
			 * through the list of keys, looking up the
			 * key at the current index in the current
			 * dictionary each time. Once we've done the
			 * lookup, we set the current dictionary to be
			 * the value we looked up (in case the value
			 * was not the last one and we are going
			 * through a chain of searches.) Note that
			 * this loop always executes at least once.
			 */

			int	tmp;
			Tcl_HashEntry *hPtr;
			Dict	*dict;
			Tcl_Obj *objPtr;
			void	**tmpPtrPtr;  // to avoid type punning

			if (write && Tcl_IsShared(currValuePtr)) {
				Tcl_Panic("A shared dict in the path\n");
			}
			if (idxCount==1) {
				/*
				 * This is unshared when writing: a
				 * loop invariant.
				 */

				lastPtr = currValuePtr;
			} else {
				int traceFlags = 0;

				unless (write) {
					traceFlags = DICT_PATH_READ;
				} else if (create) {
					traceFlags = DICT_PATH_CREATE;
				} else {
					traceFlags = DICT_PATH_UPDATE;
				}

				lastPtr = TclTraceDictPath(interp,
				    currValuePtr, idxCount-1, idxPtr,
				    traceFlags);
				unless (lastPtr) goto undef;
				if (write && Tcl_IsShared(lastPtr)) {
					Tcl_Panic(
					    "Shared lastPtr of dict type");
				}
			}

			/*
			 * Look for the corresponding entry. Get into
			 * the dict guts ...
			 *
			 * Try to build the deep pointers into Tcl?
			 * Avoid looking up twice, but also avoid
			 * having to replicate too much of the dict or
			 * list implementations.
			 */

			if (TCL_OK != Tcl_DictObjSize(NULL, lastPtr, &tmp)) {
				/*
				 * lastPtr is not a dict!
				 */
				goto undef;
			}
			dict = (Dict *) lastPtr->internalRep.otherValuePtr;
			hPtr = Tcl_FindHashEntry(&dict->table,
			    (char *)idxPtr[idxCount-1]);
			unless (hPtr) {
				unless (create) goto undef;
				objPtr = Tcl_NewObj();
				Tcl_IncrRefCount(objPtr);
				result = Tcl_DictObjPut(interp, lastPtr,
				    idxPtr[idxCount-1], objPtr);
				Tcl_DecrRefCount(objPtr);
				if (result != TCL_OK) goto undef;
				hPtr = Tcl_FindHashEntry(&dict->table,
				    (char *)idxPtr[idxCount-1]);
				tmpPtrPtr = &Tcl_GetHashValue(hPtr);
				resultPtrPtr = (Tcl_Obj **)tmpPtrPtr;
			}
			tmpPtrPtr = &Tcl_GetHashValue(hPtr);
			resultPtrPtr = (Tcl_Obj **)tmpPtrPtr;
			if (write && Tcl_IsShared(*resultPtrPtr) &&
			    (i != numLevels-1)) {
				Tcl_DecrRefCount(*resultPtrPtr);
				*resultPtrPtr = Tcl_DuplicateObj(*resultPtrPtr);
				Tcl_IncrRefCount(*resultPtrPtr);
			}
		} else {
			if (write) {
				resultPtrPtr = L_LsetFlatExtend(interp,
					currValuePtr, idxCount, idxPtr);
				unless (resultPtrPtr) goto neg;
			} else {
				resultPtrPtr = L_LindexFlat(interp,
					currValuePtr, idxCount, idxPtr);
				unless (resultPtrPtr) goto undef;
			}
		}

		if (write) {
			Tcl_InvalidateStringRep(currValuePtr);
		}
		currValuePtr = *resultPtrPtr;
		if (write && Tcl_IsShared(currValuePtr) && (i != numLevels-1)) {
			Tcl_Panic("L deep-dive internal error 2");
		}
		idxPtr += idxCount;
		levelCountPtr++;
		typeIsHash = !typeIsHash;
	}

	if (write && (valuePtr->refCount != 1)) {
		fprintf(stderr, "valuePtr %p:'%s', currValuePtr %p:'%s'\n",
		    valuePtr, TclGetString(valuePtr), currValuePtr,
		    TclGetString(currValuePtr));
		Tcl_Panic("L_DeepDiveIntoStruct called for writing, "
		    "exiting with obj with refCount = %i != 1!",
		    valuePtr->refCount);
	}

 done:
	Tcl_DecrRefCount(countPtr);
	return resultPtrPtr;

 neg:
	Tcl_ResetResult(interp);
	Tcl_AppendResult(interp, "cannot write to negative array index", NULL);
	resultPtrPtr = NULL;
	goto done;

 undef:
	if (write) L_bomb("L deep-dive internal error");
	resultPtrPtr = get_undef_obj();
	goto done;
}

/*
 * This function executes the INST_L_SPLIT bytecode and is based on
 * pieces from tclCmdMZ.c.
 *
 * For edge cases, some of Perl's "split" semantics are obeyed:
 *
 * - A limit <= 0 means no limit.
 *
 * - If the regexp is ' ', we split on white space but leading
 *   white space does not produce a null first field.
 *
 * - No regexp means split on white space.
 */
Tcl_Obj *
L_split(Tcl_Interp *interp, Tcl_Obj *strobj, Tcl_Obj *reobj, Tcl_Obj *limobj)
{
	int		end, lim, matches, off, ret, start;
	int		ondefault=0, onspace=0;
	Tcl_RegExp	regExpr;
	Tcl_RegExpInfo	info;
	Tcl_Obj		*resultPtr, *objPtr, *listPtr;
	char		*str;
	int		len;

	if (limobj) {
		Tcl_GetIntFromObj(interp, limobj, &lim);
		if (lim <= 0) {
			lim = INT_MAX;
		} else {
			/* The lim is the max # fields to return,
			 * which is one less than the max # matches to
			 * allow. */
			--lim;
		}
	} else {
		lim = INT_MAX;
	}

	/*
	 * Check for the cases of no regexpr (split on white space) or
	 * splitting on ' ' (split on white space but don't return a
	 * null field for any leading white space).
	 */
	if (reobj) {
		unless (strcmp(" ", Tcl_GetString(reobj))) onspace = 1;
	} else {
		ondefault = 1;
	}

	/*
	 * Make sure to avoid problems where the objects are shared. This can
	 * cause RegExpObj <> UnicodeObj shimmering that causes data corruption.
	 * [Bug #461322]
	 */
	if (strobj == reobj) {
		objPtr = Tcl_DuplicateObj(strobj);
	} else {
		objPtr = strobj;
	}
	str = TclGetStringFromObj(objPtr, &len);

	listPtr = Tcl_NewObj();
	matches = 0;
	off     = 0;

	/*
	 * Split on white space if no regexp or ' ' was specified.  No
	 * need for the regexp engine here.
	 */
	if (ondefault || onspace) {
		int letters = 0, skip = 0;
		for (start = 0; (off < len) && (matches < lim); ++off) {
			if (skip) {
				unless (isspace(str[off])) {
					start   = off;
					letters = 1;
					skip    = 0;
					++matches;
				}
			} else {
				if (isspace(str[off])) {
					/* When regexp is ' ', create no null
					 * field for leading white space. */
					unless (onspace && !off && !start) {
						resultPtr = Tcl_NewStringObj(
								str+start,
								off-start);
						Tcl_ListObjAppendElement(
								NULL, listPtr,
								resultPtr);
					}
					skip = 1;
				} else letters = 1;
			}
		}
		unless (skip) {
			resultPtr = Tcl_NewStringObj(str+start, len-start);
			Tcl_ListObjAppendElement(NULL, listPtr, resultPtr);
		}
		/* If input was all whitespace, return empty list. */
		unless (letters || !lim) listPtr = Tcl_NewObj();
		goto done;
	}

	/*
	 * Split on the specified regular expression.
	 */
	regExpr = Tcl_GetRegExpFromObj(interp, reobj,
				       TCL_REG_ADVANCED | TCL_REG_PCRE);
	if (regExpr == NULL) {
		listPtr = Tcl_NewObj();
		goto done;
	}
	while ((off < len) && (matches < lim)) {
		ret = Tcl_RegExpExecObj(interp, regExpr, objPtr, off,
				10 /* matches */,
				((off > 0 && (str[off-1] != '\n'))
				? TCL_REG_NOTBOL : 0));
		if (ret < 0) goto done;
		if (ret == 0) break;

		Tcl_RegExpGetInfo(regExpr, &info);
		start = info.matches[0].start;
		end   = info.matches[0].end;
		matches++;

		/*
		 * Copy to the result list the portion of the source
		 * string before the match. If we matched the empty
		 * string, split after the current char.
		 */
		if (start == end) {
			/* Note: start will always be 0 if start==end. */
			resultPtr = Tcl_NewStringObj(str+off, 1);
			++off;
		} else {
			resultPtr = Tcl_NewStringObj(str+off, start);
		}
		Tcl_ListObjAppendElement(NULL, listPtr, resultPtr);
		off += end;
	}
	/*
	 * Copy to the result list the portion of the source string after
	 * the last match, unless we matched the last char.
	 */
	if (off < len) {
		resultPtr = Tcl_NewStringObj(str+off, len-off);
		Tcl_ListObjAppendElement(NULL, listPtr, resultPtr);
	}

 done:
	if (objPtr && (strobj == reobj)) {
		Tcl_DecrRefCount(objPtr);
	}
	return listPtr;
}
