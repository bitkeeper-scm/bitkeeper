# This file is part of the BitKeeper Regression test suite.
# All of the files in this directory are Copyright (c) 2000 BitMover, Inc.
# and are not licensed under the terms of the BKL (BitKeeper License).
# Standard copyright law applies.
# 
# Redistribution in modified form is prohibited with one exception:
#    proposed modifications may be sent back to dev@bitmover.com for
#    possible inclusion in future releases.  Sending such modifications
#    constitutes your permission for BitMover, Inc. to distribute  the
#    modifications under any license.

DASHA=
test X`uname -s` = XDarwin && DASHA=-a

echo $N Check commit trigger environment variables ..................$NL
cd $HERE
no_logging project
bk edit $Q BitKeeper/etc/config
echo "checkout: get" >> BitKeeper/etc/config
bk delta $Q -ycheckout BitKeeper/etc/config
bk commit $Q -ycheckout
mkdir BitKeeper/triggers
cat > BitKeeper/triggers/pre-commit <<EOF
#!/bin/sh
set | grep $DASHA BK | sort > $HERE/pre-commit
exit 0
EOF
cat > BitKeeper/triggers/post-commit <<EOF
#!/bin/sh
set | grep $DASHA BK | sort > $HERE/post-commit
exit 0
EOF
chmod +x BitKeeper/triggers/*
echo h > h.h
bk ci $Q -i h.h
bk commit $S -a -yCset
grep -q BK_CSETS $HERE/pre-commit && {
	echo should not have defined BK_CSETS in pre-commit
	exit 1
}
grep -q BK_STATUS=OK $HERE/post-commit || {
	echo no/bad exit status
	cat $HERE/post-commit
	exit 1
}
echo OK
test -z "$DUMP_VARS" || {
	echo ========== pre-commit ==========
	cat $HERE/pre-commit
	echo ========== post-commit ==========
	cat $HERE/post-commit
}

echo $N Make sure commit can be told to fail and it does so nicely ..$NL
cat > BitKeeper/triggers/pre-commit <<EOF
#!/bin/sh
exit 1
EOF
chmod +x BitKeeper/triggers/*
echo c > c.c
bk ci $Q -i c.c
bk commit $S -a -yCset2 2>/dev/null && {
	echo failed to exit with an error status
	exit 1
}
if [ `bk sfiles -gp` != c.c ]
then	echo bad pending list
	exit 1
fi
echo OK

echo $N Make sure we get the list of pending files in pre-commit ....$NL
cat > BitKeeper/triggers/pre-commit <<EOF
#!/bin/sh 
cp \$BK_PENDING $HERE/BK_PENDING
exit 1
EOF
chmod +x BitKeeper/triggers/*
bk commit $S -a -yCset2 2>/dev/null && {
	echo failed to exit with an error status
	exit 1
}
test -f $HERE/BK_PENDING || {
	echo failed to copy the file
	exit 1
}
test SCCS/s.c.c${BK_FS}1.1 = `cat $HERE/BK_PENDING` || {
	echo bad file list
	cat $HERE/BK_PENDING
	exit 1
}
echo OK

echo $N Extract user from file list of pending deltas ...............$NL
test `bk prs -hd':USER:\n' - < $HERE/BK_PENDING` = bk || {
	echo can not extract user from file list
	exit 1
}
echo OK

echo $N Make sure commit succeeds when told it is OK ................$NL
cat > BitKeeper/triggers/pre-commit <<EOF
#!/bin/sh
exit 0
EOF
chmod +x BitKeeper/triggers/*
bk commit $S -a -yCset2 || {
	echo failed
	exit 1
}
echo OK

echo $N Make sure clone is passed the right variables ...............$NL
cat > BitKeeper/triggers/pre-outgoing <<EOF
#!/bin/sh
set | grep $DASHA BK | sort > $HERE/pre-outgoing
exit 1
EOF
cat > BitKeeper/triggers/post-outgoing <<EOF
#!/bin/sh
set | grep $DASHA BK | sort > $HERE/post-outgoing
EOF
chmod +x BitKeeper/triggers/*
project_repoid=`bk identity -r`
cd $HERE
bk clone $Q project clone && {
	echo failed to exit with an error status
	exit 1
}
test -d clone && {
	echo should not have created repository
	exit 1
}
bk clone $Q -r1.1 project clone 
grep -q BK_CSETS=1.0..1.1 $HERE/pre-outgoing || {
	echo failed to put cset list in the env
	exit 1
}
rm project/BitKeeper/triggers/pre-outgoing
bk clone $Q -r1.1 project clone || {
	echo should have succeeded and did not
	exit 1
}
bk clone $Q -r1.1 project apply || {
	echo should have succeeded and did not
	exit 1
}
test -d clone || {
	echo should have created repository
	exit 1
}
grep -q BK_CSETS=1.0..1.1 $HERE/post-outgoing || {
	echo failed to put cset list in the env
	exit 1
}
grep BKD_REPO_ID= $HERE/post-outgoing > $HERE/tmp
fgrep "$project_repoid" $HERE/tmp > /dev/null || {
	echo "failed to record where we came from which is $project_repoid"
	cat $HERE/post-outgoing
	exit 1
}
echo OK
test -z "$DUMP_VARS" || {
	echo ========== pre-outgoing clone ==========
	cat $HERE/pre-outgoing
	echo ========== post-outgoing clone ==========
	cat $HERE/post-outgoing
}

# win32 cannot support lclone
if [ "$PLATFORM" != "WIN32" ]
then #-----------------------------------------------------------------
echo $N Make sure clone -l is passed the right variables ............$NL
cd $HERE/project
cat > BitKeeper/triggers/pre-outgoing <<EOF
#!/bin/sh
set | grep $DASHA BK | grep -v BK_LCLONE | sort > $HERE/pre-outgoing-l
exit 1
EOF
cat > BitKeeper/triggers/post-outgoing <<EOF
#!/bin/sh
set | grep $DASHA BK | grep -v BK_LCLONE | sort > $HERE/post-outgoing-l
EOF
chmod +x BitKeeper/triggers/*
cd $HERE
bk clone -l $Q project lclone && {
	echo failed to exit with an error status
	exit 1
}
test -d lclone && {
	echo should not have created repository
	exit 1
}
bk clone $Q -l -r1.1 project lclone 
grep -q BK_CSETS=1.0..1.1 $HERE/pre-outgoing || {
	echo failed to put cset list in the env
	exit 1
}
rm project/BitKeeper/triggers/pre-outgoing
bk clone $Q -l -r1.1 project lclone || {
	echo should have succeeded and did not
	exit 1
}
test -d lclone || {
	echo should have created repository
	exit 1
}
grep -q BK_CSETS=1.0..1.1 $HERE/post-outgoing || {
	echo failed to put cset list in the env
	exit 1
}
echo OK
test -z "$DUMP_VARS" || {
	echo ========== pre-outgoing clone -l ==========
	cat $HERE/pre-outgoing-l
	echo ========== post-outgoing clone -l ==========
	cat $HERE/post-outgoing-l
}

echo $N Make sure clone and clone -l have same pre-outgoing .........$NL
cmp -s $HERE/pre-outgoing $HERE/pre-outgoing-l || {
	echo failed
	diff $HERE/pre-outgoing $HERE/pre-outgoing-l
	exit 1
}
echo OK

echo $N Make sure clone and clone -l have same post-outgoing ........$NL
cmp -s $HERE/post-outgoing $HERE/post-outgoing-l || {
	echo failed
	diff $HERE/post-outgoing $HERE/post-outgoing-l
	exit 1
}
echo OK
fi #---------------------------------------------------------------------

# Make a post-incoming trigger be checked in, see if clone runs it.
echo $N Test post-incoming in a clone ...............................$NL
cd $HERE
cp -rp project parent
cd parent
rm -f BitKeeper/triggers/*
cat > BitKeeper/triggers/post-incoming <<EOF
#!/bin/sh
# ignore BK_REPO_ID because clone and clone-l had different ids
set | grep $DASHA BK |
    grep -v BK_IGNORELOCK |
    grep -v BKD_LEVEL |
    grep -v BK_REPO_ID |
    sort > $HERE/post-incoming-clone
exit 0
EOF
chmod +x BitKeeper/triggers/post-incoming
bk new $Q BitKeeper/triggers/post-incoming
bk commit $Q -ypost-incoming
cd $HERE
bk clone $Q parent clone2
test -f $HERE/post-incoming-clone || {
	echo failed to run post-incoming trigger
	exit 1
}
grep BKD_REPO_ID= $HERE/post-incoming-clone > $HERE/tmp
fgrep "$project_repoid" $HERE/tmp > /dev/null || {
	echo "failed to record where we came from which is $project_repoid"
	cat $HERE/post-incoming-clone
	exit 1
}
echo OK
test -z "$DUMP_VARS" || {
	echo ========== post-incoming clone ==========
	cat $HERE/post-incoming-clone
}

if [ "$PLATFORM" != "WIN32" ]
then #-----------------------------------------------------------------
# Make a post-incoming trigger be checked in, see if clone -l runs it.
echo $N Test post-incoming in a clone -l ............................$NL
cd $HERE/parent
bk edit $Q BitKeeper/triggers
cat > BitKeeper/triggers/post-incoming <<EOF
#!/bin/sh
set | grep $DASHA BK |
    grep -v BK_LCLONE |
    grep -v _BK_ |
    grep -v BK_REPO_ID |
    sort > $HERE/post-incoming-clone-l
exit 0
EOF
chmod +x BitKeeper/triggers/post-incoming
bk delta -y-l $Q BitKeeper/triggers/post-incoming
bk commit $Q -ypost-incoming-l
cd $HERE
rm -rf clone2
bk clone -l $Q parent clone2
test -f $HERE/post-incoming-clone-l || {
	echo failed to run post-incoming trigger
	exit 1
}
echo OK
test -z "$DUMP_VARS" || {
	echo ========== post-incoming clone -l ==========
	cat $HERE/post-incoming-clone-l
}

echo $N Make sure clone and clone -l have same post-incoming ........$NL
cmp -s $HERE/post-incoming-clone $HERE/post-incoming-clone-l || {
	echo failed
	diff $HERE/post-incoming-clone $HERE/post-incoming-clone-l
	exit 1
}
echo OK
fi #-------------------------------------------------------------------
cd $HERE
rm -rf parent clone2

echo $N Make sure pull is passed the right variables ................$NL
cd $HERE/project
cat > BitKeeper/triggers/pre-outgoing <<EOF
#!/bin/sh
set | grep $DASHA BK | sort > $HERE/pre-outgoing
cp \$BK_CSETLIST $HERE/CSETS
exit 1
EOF
chmod +x BitKeeper/triggers/*
cd $HERE/clone
bk pull $Q && {
	echo failed to exit with an error status
	exit 1
}
grep -q BK_CSETLIST $HERE/pre-outgoing || {
	echo failed to put cset list file in the env
	cat $HERE/pre-outgoing
	exit 1
}
grep -q BK_LOCALCSETS=2 $HERE/pre-outgoing || 
grep -q BK_LOCALCSETS=3 $HERE/pre-outgoing || {
	echo failed to put local csets in the env
	cat $HERE/pre-outgoing
	exit 1
}
grep -q BK_REMOTECSETS=0 $HERE/pre-outgoing || {
	echo failed to put remote csets in the env
	cat $HERE/pre-outgoing
	exit 1
}
test -d RESYNC && {
	echo failed to clean up RESYNC dir
	exit 1
}
echo OK

echo $N Make sure pre-incoming triggers fail the pull ...............$NL
rm $HERE/project/BitKeeper/triggers/pre-outgoing
cd $HERE/clone
mkdir BitKeeper/triggers
cat > BitKeeper/triggers/pre-incoming <<EOF
#!/bin/sh
set | grep $DASHA BK | sort > $HERE/pre-incoming
exit 1
EOF
chmod +x BitKeeper/triggers/*
bk pull $Q && {
	echo failed to exit non zero with failed pre-incoming trigger
	exit 1
}
test -d RESYNC && {
	echo failed to clean up RESYNC
	exit 1
}
echo OK
test -z "$DUMP_VARS" || {
	echo ========== pre-incoming ==========
	cat $HERE/pre-incoming
}

echo $N Make sure pre-resolve triggers fail the pull ................$NL
cd $HERE/clone
rm BitKeeper/triggers/*
cat > BitKeeper/triggers/pre-resolve <<EOF
#!/bin/sh
set | grep $DASHA BK | sort > $HERE/pre-resolve
pwd > $HERE/PWD
exit 1
EOF
chmod +x BitKeeper/triggers/*
bk pull $Q && {
	echo failed to exit non zero with failed pre-resolve trigger
	exit 1
}
test -d RESYNC && {
	echo failed to clean up RESYNC
	exit 1
}
test -f $HERE/pre-resolve || {
	echo failed to call trigger
	exit 1
}
echo OK
test -z "$DUMP_VARS" || {
	echo ========== pre-resolve ==========
	cat $HERE/pre-resolve
}

echo $N Make sure we can see the data in the pre-resolve trigger ....$NL
cat > BitKeeper/triggers/pre-resolve <<EOF
#!/bin/sh
bk changes - < \$BK_CSETLIST > $HERE/changes
cp \$BK_CSETLIST $HERE/csets-out
pwd > $HERE/resolve-pwd
exit 1
EOF
chmod +x BitKeeper/triggers/*
bk pull $Q && {
	echo failed to exit non zero with failed pre-incoming trigger
	exit 1
}
test -d RESYNC && {
	echo failed to clean up RESYNC
	exit 1
}
test -s $HERE/changes || {
	echo failed to create change list
	exit 1
}
grep -q ChangeSet@1.3 $HERE/changes || {
	echo failed to list the ChangeSet
	exit 1
}
GOT=`wc -l < $HERE/csets-out`
if [ $GOT -ne 2 -a $GOT -ne 3 ]; then
	echo csets-out contains extra junk
	cat $HERE/csets-out
	exit 1
fi
GOT=`grep '^ChangeSet' $HERE/changes | wc -l`
if [ $GOT -ne 2 -a $GOT -ne 3 ]; then
	echo listed extra changes
	exit 1
fi
echo OK

echo $N Make sure the pre-resolve trigger is run in RESYNC ..........$NL
grep -q RESYNC $HERE/resolve-pwd || {
	echo failed
	cat RESYNC $HERE/resolve-pwd
	exit 1
}
echo OK

echo $N Check bk changes -v - .......................................$NL
echo 1.1 > list
echo junk >> list
bk changes - < list > /dev/null 2>&1 && {
	echo failed to reject junk
	exit 1
}
echo 1.1 > list
echo \#junk >> list
echo >> list
bk changes - < list > out || {
	echo didn\'t ignore blanks and comments
	exit 1
}
if [ `grep '^ChangeSet' out | wc -l` -ne 1 ]; then
	echo returned extra junk
	exit 1
fi
echo OK

echo $N Make sure pre-apply exiting 1 cleans up .....................$NL
cd $HERE/apply
test -d BitKeeper/triggers || mkdir BitKeeper/triggers
cat > BitKeeper/triggers/pre-apply <<EOF
#!/bin/sh
set | grep $DASHA BK | sort -u > $HERE/pre-apply
pwd > $HERE/apply-pwd
exit 1
EOF
chmod +x BitKeeper/triggers/*
bk pull $Q && {
	echo failed to exit non zero with failed pre-apply trigger
	exit 1
}
test -d RESYNC && {
	echo failed to clean up RESYNC
	exit 1
}
test -d PENDING && {
	echo failed to clean up PENDING
	exit 1
}
echo OK
test -z "$DUMP_VARS" || {
	echo ========== pre-apply ==========
	cat $HERE/pre-apply
}

echo $N Make sure the pre-apply trigger is run in RESYNC ............$NL
grep -q RESYNC $HERE/apply-pwd || {
	echo failed
	cat RESYNC $HERE/apply-pwd
	exit 1
}
echo OK

echo $N Make sure pre-apply exiting 2 leaves patch in PENDING .......$NL
cd $HERE/apply
test -d BitKeeper/triggers || mkdir BitKeeper/triggers
cat > BitKeeper/triggers/pre-apply <<EOF
#!/bin/sh
exit 2
EOF
chmod +x BitKeeper/triggers/*
bk pull $Q && {
	echo failed to exit non zero with failed pre-apply trigger
	exit 1
}
test -d RESYNC && {
	echo failed to clean up RESYNC
	exit 1
}
test -d PENDING || {
	echo failed to leave PENDING
	exit 1
}
echo OK

echo $N Make sure pre-apply exiting 3 leaves RESYNC and PENDING .....$NL
cd $HERE/apply
test -d BitKeeper/triggers || mkdir BitKeeper/triggers
cat > BitKeeper/triggers/pre-apply <<EOF
#!/bin/sh
exit 3
EOF
chmod +x BitKeeper/triggers/*
bk pull $Q && {
	echo failed to exit non zero with failed pre-apply trigger
	exit 1
}
X="RESYNC-*"
test "$X" || {
	echo failed to leave RESYNC
	exit 1
}
test -d PENDING || {
	echo failed to leave PENDING
	exit 1
}
echo OK

echo $N Make sure we can see the data in the post-incoming trigger ..$NL
cd $HERE/clone
rm BitKeeper/triggers/* $HERE/changes
cat > BitKeeper/triggers/post-incoming <<EOF
#!/bin/sh
bk changes - < \$BK_CSETLIST > $HERE/changes
set | grep $DASHA BK | sort -u > $HERE/post-incoming
EOF
chmod +x BitKeeper/triggers/*
clone_repoid=`bk identity -r`
bk pull $Q || {
	echo failed to exit zero
	exit 1
}
test -d RESYNC && {
	echo failed to clean up RESYNC
	exit 1
}
test -s $HERE/changes || {
	echo failed to create change list
	exit 1
}
grep -q ChangeSet@1.3 $HERE/changes || {
	echo failed to list the ChangeSet
	exit 1
}
grep BKD_REPO_ID= $HERE/post-incoming > $HERE/tmp
fgrep "$project_repoid" $HERE/tmp > /dev/null || {
	echo failed to record where we came from
	exit 1
}
grep BK_REPO_ID= $HERE/post-incoming > $HERE/tmp
fgrep "$clone_repoid" $HERE/tmp > /dev/null || {
	echo failed to record where we are
	exit 1
}
echo OK
test -z "$DUMP_VARS" || {
	echo ========== post-incoming ==========
	cat $HERE/post-incoming
}

echo $N Fail a push in pre-incoming and make sure we clean up .......$NL
rm $HERE/pre-* $HERE/post-*
cd $HERE/project
rm BitKeeper/triggers/*
cat > BitKeeper/triggers/pre-incoming <<EOF
#!/bin/sh
echo I am the remote pre-incoming trigger and I am failing
set | grep $DASHA BK | sort > $HERE/pre-incoming
exit 1
EOF
chmod +x BitKeeper/triggers/*
cd $HERE/clone
ls > LS
bk new $Q LS
bk commit -ywhatever $Q
bk push 2>OUT && {
	echo push should have failed
	exit 1
}
test -d ../project/RESYNC && {
	echo failed to clean up RESYNC
	exit 1
}
test -d ../project/PENDING && {
	echo failed to clean up PENDING
	exit 1
}
grep -q 'I am the remote pre-incoming trigger' OUT || {
	echo failed to pass back the trigger message
	cat OUT
	exit 1
}
echo OK
test -z "$DUMP_VARS" || {
	echo ====== pre-push-incoming ==========
	cat $HERE/pre-incoming
}

echo $N Make sure pull -R does not run post-incoming ................$NL
rm -f $HERE/pre-* $HERE/post-*
cd $HERE/project
rm BitKeeper/triggers/*
cat > BitKeeper/triggers/post-incoming <<EOF
#!/bin/sh
echo I am the post-incoming trigger
set | grep $DASHA BK | sort > $HERE/post-incoming
exit 1
EOF
chmod +x BitKeeper/triggers/*
cd $HERE/clone
ls > whatever
bk new $Q whatever
bk commit -ywhatever $Q
cd $HERE/project
bk pull -R $HERE/clone 2>OUT || {
	echo pull should not have failed
	exit 1
}
test -d RESYNC || {
	echo failed to leave RESYNC
	exit 1
}
test -f $HERE/post-incoming && {
	echo should not have run trigger, we did not finish
	exit 1
}
echo OK

echo $N Make sure resolve does run the post-incoming ................$NL
rm -f $HERE/post-incoming
bk resolve >OUT 2>&1 || {
	echo resolve should not have failed
	exit 1
}
test -d RESYNC && {
	echo failed to clean up RESYNC
	exit 1
}
test -f $HERE/post-incoming || {
	echo should have run trigger, we did finish
	exit 1
}
echo OK
test -z "$DUMP_VARS" || {
	echo ====== resolve post-incoming ==========
	cat $HERE/post-incoming
}

echo $N Fail a push in pre-resolve and make sure we clean up ........$NL
cd $HERE/project
bk undo -qsfr+
rm BitKeeper/triggers/*
cat > BitKeeper/triggers/pre-resolve <<EOF
#!/bin/sh
echo pre-resolve failing
set | grep $DASHA BK | sort >> $HERE/pre-resolve
exit 1
EOF
chmod +x BitKeeper/triggers/*
waitForUnlock $HERE/project
cd $HERE/clone
rm -f BitKeeper/triggers/* $HERE/pre-resolve
bk push 2>OUT && {
	echo push should have failed
	cat OUT
	exit 1
}
test -d ../project/RESYNC && {
	echo failed to clean up RESYNC
	exit 1
}
test -d ../project/PENDING && {
	echo failed to clean up PENDING
	exit 1
}
grep -q 'pre-resolve failing' OUT || {
	echo failed to pass back trigger output
	cat OUT
	exit 1
}
echo OK
test -z "$DUMP_VARS" || {
	echo ====== pre-resolve ==========
	cat $HERE/pre-resolve
}

echo $N Exit 2 out of a pre-resolve, make sure it leaves the patch ..$NL
cd $HERE/project
rm BitKeeper/triggers/*
cat > BitKeeper/triggers/pre-resolve <<EOF
#!/bin/sh
echo pre-resolve failing but leaving patch
set | grep $DASHA BK | sort >> $HERE/pre-resolve
exit 2
EOF
chmod +x BitKeeper/triggers/*
cd $HERE/clone
rm -f BitKeeper/triggers/* $HERE/pre-resolve
bk push 2>OUT && {
	echo push should have failed
	exit 1
}
test -d ../project/RESYNC && {
	echo failed to clean up RESYNC
	exit 1
}
test -d ../project/PENDING || {
	echo failed to leave PENDING
	exit 1
}
grep -q 'pre-resolve failing but leaving patch' OUT || {
	echo failed to pass back trigger output
	cat OUT
	exit 1
}
echo OK
test -z "$DUMP_VARS" || {
	echo ====== pre-resolve ==========
	cat $HERE/pre-resolve
}

echo $N Look for cset list in pre-resolve in the push ...............$NL
cd $HERE/clone
cat > $HERE/project/BitKeeper/triggers/pre-resolve <<EOF
#!/bin/sh
bk changes - < \$BK_CSETLIST > $HERE/changes
exit 1
EOF
chmod +x $HERE/project/BitKeeper/triggers/*
bk push $Q && {
	echo failed to exit nonzero
	exit 1
}
test -d $HERE/project/RESYNC && {
	echo failed to clean up RESYNC
	exit 1
}
test -s $HERE/changes || {
	echo failed to create change list
	exit 1
}
grep -q ChangeSet@1.5 $HERE/changes || 
grep -q ChangeSet@1.6 $HERE/changes || {
	echo failed to list the ChangeSet
	cat $HERE/changes
	exit 1
}
echo OK

echo $N Look for cset list in post in the push ......................$NL
cd $HERE/clone
rm $HERE/project/BitKeeper/triggers/* $HERE/changes
cat > $HERE/project/BitKeeper/triggers/post-incoming <<EOF
#!/bin/sh
bk changes - < \$BK_CSETLIST > $HERE/changes
exit 0
EOF
chmod +x $HERE/project/BitKeeper/triggers/*
bk push $Q || {
	echo failed to exit zero, exited $?
	exit 1
}
test -s $HERE/changes || {
	echo failed to create change list
	exit 1
}
grep -q ChangeSet@1.5 $HERE/changes || 
grep -q ChangeSet@1.6 $HERE/changes || {
	echo failed to list the ChangeSet
	exit 1
}
echo OK

cd $HERE
rm -rf *

echo $N Create initial repository ...................................$NL
no_logging project
if [ ! -d BitKeeper/etc ]; then echo failed to make BitKeeper/etc; exit 1; fi
if [ ! -f SCCS/s.ChangeSet ]; then echo failed to make ChangeSet; exit 1; fi
P=`bk pending | wc -l`
if [ $P -ne 0 ]; then echo files are pending; bk pending; exit 1; fi
mkdir src
cd src
echo foo > foo.c
echo bar > bar.c
echo h > h.h
bk ci $Q -i foo.c bar.c h.h
if [ ! -f SCCS/s.foo.c ]; then echo failed to create history; exit 1; fi
P=`bk pending | wc -l`
if [ $P -ne 15 ]; then echo wrong pending result $P; bk pending; exit 1; fi
bk commit $S -a -yCset
P=`bk pending | wc -l`
if [ $P -ne 0 ]; then echo failed to clear pending list; bk pending; exit 1; fi
echo OK
cores

echo $N Create trivial server side triggers .........................$NL
cd $HERE
mkdir project/BitKeeper/triggers || exit 1
cd project/BitKeeper/triggers
echo "#! /bin/sh"                > good
#echo "echo \`bk root\`/\$0: trigger fired"	>> good
echo "bk root"			>> good
echo "PROOT=\`bk root\`"			>> good
echo "echo \$PROOT/\$0: trigger fired"	>> good
echo "exit 0"                   >> good
bk undos good > X
chmod +x X
for x in pre post;do
	for y in commit incoming outgoing;do
		cp X $x-$y
	done
done

# Overwrite the pre incoming trigger with a more interesting one
cat >good2 <<EOF
#! /bin/sh
echo "\`bk root\`/\$0: trigger fired"
test "X$BK_RESYNC" = XFALSE || exit 0
if [ ! -d RESYNC ]; then echo "missing RESYNC TREE"; exit 1; fi
if [ X\$BK_OUTGOING_USER != X`bk getuser` ]; then echo "Wrong user"; exit 1; fi
echo "post-incoming trigger: user=\$BK_OUTGOING_USER"
REV=\`cat RESYNC/BitKeeper/etc/csets-in\`
echo "incoming rev=\$REV"
for i in $REV
do	echo ChangeSet${BK_FS}$i
done | bk prs -h -
exit 0
EOF
bk undos good2 > pre-incoming
chmod +x pre-incoming

cd $HERE
echo "OK"

echo $N Clone w/trivial triggers ....................................$NL
cd $HERE
bk clone $Q $HERE/project $HERE/copy 2> /dev/null || { echo failed; exit 1; }
echo OK

echo $N Create trivial client side triggers .........................$NL
cd $HERE
mkdir copy/BitKeeper/triggers || exit 1
cd copy/BitKeeper/triggers
echo "#! /bin/sh"                > good
echo "echo \`bk root\`/\$0: trigger fired"	>> good
echo "exit 0"                   >> good
chmod +x good
for x in pre post;do
	for y in commit incoming outgoing;do
		cp good $x-$y
	done
done
cd $HERE
echo "OK"

echo $N Make sure delta fails with pre-delta trigger ................$NL
cp -rp $HERE/project $HERE/delta
cd $HERE/delta/BitKeeper/triggers
cat > pre-delta <<EOF
#!/bin/sh

set | grep $DASHA BK | sort > $HERE/pre-delta
echo You bozo, you forgot to cstyle \$BK_FILE
exit 1
EOF
chmod +x pre-delta
cd $HERE/delta/src
bk get $Q -e foo.c
echo bad form, dude >> foo.c
bk delta $Q -y'This is a multi
line comment,
to test if that works' foo.c > OUT 2>&1 && {
	echo delta should have failed
	exit 1
}
test -f SCCS/p.foo.c || {
	echo delta should have failed
	exit 1
}
grep -q 'you forgot to cstyle foo.c' OUT || {
	echo bad error message
	cat OUT
	exit 1
}
grep -q BK_FILE= $HERE/pre-delta || {
	echo failed to set BK_FILE
	exit 1
}
echo OK
test -z "$DUMP_VARS" || {
	echo ====== pre-delta ==========
	cat $HERE/pre-delta
}

if [ X$BK_TESTGUI != X ]; then
    echo $N citool w/failing pre-delta trigger...........................$NL
    bk citool
    echo OK
    echo $N citool w/working pre-delta trigger...........................$NL
    cd $HERE/delta/BitKeeper/triggers
    cat > pre-delta <<EOF
#!/bin/sh

echo You bozo, you forgot to cstyle \$BK_FILE
echo I am letting slide just this once.
exit 0
EOF
    bk citool
    echo OK
fi

echo $N Test that a pre-delta trigger will work from command line ...$NL
cd $HERE
cp -rp delta aaron
cd $HERE/aaron/BitKeeper/triggers
cat > pre-delta <<EOF
#!/bin/sh

echo You bozo, you forgot to cstyle \$BK_FILE
echo I am letting slide just this once.
exit 0
EOF
cd $HERE/aaron/src
bk get $Q -e foo.c
echo bad form, dude >> foo.c
bk ci -p -ywhatever foo.c > OUT 2>&1
test -f SCCS/p.foo.c && {
	echo failed to do the delta
	cat OUT
	exit 1
}
grep -q 'bad form, dude' OUT || {
	echo bad diffs
	cat OUT
	exit 1
}
echo OK

echo $N Test that a pre-delta trigger can delta the file ............$NL
cd $HERE/delta/BitKeeper/triggers
cat > pre-delta <<EOF
#!/bin/sh

bk delta -y'I am the trigger' $BK_FILE
exit 2
EOF
chmod +x pre-delta
cd $HERE/delta/src
bk get $Q -e foo.c
echo bad form, dude >> foo.c
echo Bad comment > SCCS/c.foo.c
bk delta foo.c >OUT 2>&1 < /dev/null || {
	echo should not have errored
	cat OUT
	exit 1
}
test -f SCCS/c.foo.c && {
	should have cleaned up c.file
	cat OUT
	exit 1
}
test 'I am the trigger' = "`bk prs -hr+ -d:C: foo.c`" || {
	echo set the wrong comment
	bk prs foo.c
	cat OUT
	exit 1
}
echo OK

cd $HERE
rm -rf delta

echo $N Commit w/trivial triggers ...................................$NL
cd $HERE/project/src
bk get $Q -e foo.c
echo 3 >> foo.c
bk delta $Q -y2 foo.c
bk commit $Q -y2 > /dev/null 2>&1 || { echo failed; exit 1; }
echo OK

if [ X$BK_TESTGUI != X ]; then
    echo $N citool w/trivial triggers ...................................$NL
    cd $HERE/project/src
    bk get $Q -e foo.c
    echo delta three >> foo.c
    bk delta $Q -y2 foo.c
    bk citool
    echo OK
fi

echo $N Pull w/trivial triggers .....................................$NL
cd $HERE/copy
bk pull -t >pull.out 2>&1 || { echo failed; exit 1; }
grep -q "1.3" pull.out
if [ $? -ne 0 ]; then echo failed 2; cat pull.out; exit 1; fi
grep -q "$HERE/project/.*BitKeeper/triggers/pre-outgoing: trigger fired" pull.out
if [ $? -ne 0 ]; then echo failed 3; cat pull.out; exit 1; fi
grep -q "$HERE/project/.*BitKeeper/triggers/post-outgoing: trigger fired" pull.out
if [ $? -ne 0 ]; then echo failed 4; cat pull.out; exit 1; fi
grep -q "$HERE/copy/.*BitKeeper/triggers/pre-incoming: trigger fired" pull.out
if [ $? -ne 0 ]; then echo failed 5; cat pull.out; exit 1; fi
grep -q "$HERE/copy/.*BitKeeper/triggers/post-incoming: trigger fired" pull.out
if [ $? -ne 0 ]; then echo failed 6; cat pull.out; exit 1; fi
echo OK

echo $N Push w/trivial triggers .....................................$NL
cd $HERE/copy/src
bk get $Q -e foo.c
echo 4 >> foo.c
bk delta $Q -y2 foo.c
bk commit $Q -y"cset comment for 1.4" > /dev/null 2>&1
bk push >push.out 2>&1 || { echo failed; cat push.out; exit 1; }
echo OK

echo $N Check BK_STATUS in push and push -n and pull -n .............$NL
cd $HERE/project/BitKeeper/triggers
rm -f *
bk undos > pre-incoming <<EOF
#! /bin/sh
set | grep $DASHA BK_STATUS
EOF
cp pre-incoming pre-outgoing

chmod +x pre*
cd $HERE/copy
rm -f BitKeeper/triggers/*
bk push -n >push.out 2>&1 || { echo failed; cat push.out; exit 1; }
grep -q BK_STATUS=DRYRUN push.out || {
	echo Failed
	cat push.out
	exit 1
}
bk push >push.out 2>&1 || { echo failed; cat push.out; exit 1; }
grep -q BK_STATUS=DRYRUN push.out && {
	echo Failed
	cat push.out
	exit 1
}
bk pull -n >pull.out 2>&1 || { echo failed; cat pull.out; exit 1; }
grep -q BK_STATUS=DRYRUN pull.out || {
	echo Failed
	cat push.out
	exit 1
}
cd $HERE/project/BitKeeper/triggers
rm -f *
echo OK

echo $N Create failure triggers .....................................$NL
cd $HERE
cd project/BitKeeper/triggers
echo "#! /bin/sh"                > bad
echo "echo negative trigger"	>> bad
echo "exit 1"                   >> bad
chmod +x bad
for y in commit incoming outgoing;do
	cp -f bad pre-$y
done
echo "OK"

echo $N Clone w/failure triggers ....................................$NL
cd $HERE
bk clone $Q $HERE/project $HERE/dontcopy && { echo failed; exit 1; }
cd $HERE/project
bk lock -U
echo OK

echo $N Commit w/failure triggers ...................................$NL
cd $HERE/project/src
bk get $Q -e foo.c
echo delta four >> foo.c
bk delta $Q -y2 foo.c
bk commit $Q -y2 > /dev/null && { echo failed; exit 1; }
echo OK

#if [ X$BK_TESTGUI != X ]; then
#    echo $N citool w/failure triggers ...................................$NL
#    cd $HERE/project/src
#    bk get $Q -e foo.c
#    echo delta five >> foo.c
#    bk delta $Q -y2 foo.c
#    bk citool
#    echo OK
#fi

echo $N Pull w/failure triggers .....................................$NL
rm -f $HERE/project/BitKeeper/triggers/*-commit
rm -rf $HERE/copy/BitKeeper/triggers
cd $HERE/project/src
bk get $Q -e foo.c
echo 5 >> foo.c
bk delta $Q -y2 foo.c
bk commit $Q -y2 

cd $HERE/copy
bk pull -t -c0 $Q && { echo failed; exit 1; }
bk lock -s || { echo failed; exit 1; }

# clean up
cd $HERE/project/src
bk undo -qfr+
echo OK

cd $HERE/copy
echo $N Push w/failure triggers .....................................$NL
cd $HERE/copy/src
bk get $Q -e foo.c
echo delta two >> foo.c
bk delta $Q -y2 foo.c
bk commit $Q -y2 || { echo failed; exit 1; }

bk push -c0 $Q && { echo failed 1; exit 1; }
bk lock -s || { echo failed 2; exit 1; }
echo OK
echo $N auto-mirroring ..............................................$NL
cd $HERE/project/BitKeeper/triggers
rm -f *
while ! bk lock -ls
do	#echo waiting for the repository to become unlocked
	sleep 1
done
bk clone $Q $HERE/project $HERE/backup || exit 1
cd $HERE/project/BitKeeper/triggers
cat > post-incoming <<EOF
#! /bin/sh
bk push $Q $HERE/backup || echo Failed to mirror the repository
EOF
chmod +x post-incoming
cd $HERE/copy/src
echo data > car.c
bk new $Q car.c
bk commit $Q -y3  
bk push $Q $HERE/project || { echo failed; exit 1; }
cd $HERE/backup
TRY=0
while [ $TRY -lt 10 ] 
do
	if [ -f $HERE/backup/src/SCCS/s.car.c ]; then break; fi
	sleep 1
	TRY=`expr $TRY + 1`
done
if [ ! -f $HERE/backup/src/SCCS/s.car.c ]; then echo failed; exit 1; fi
echo OK
