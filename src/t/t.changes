# This file is part of the BitKeeper Regression test suite.
# All of the files in this directory are Copyright (c) 2000 BitMover, Inc.
# and are not licensed under the terms of the BKL (BitKeeper License).
# Standard copyright law applies.
# 
# Redistribution in modified form is prohibited with one exception:
#    proposed modifications may be sent back to dev@bitmover.com for
#    possible inclusion in future releases.  Sending such modifications
#    constitutes your permission for BitMover, Inc. to distribute  the
#    modifications under any license.


# Copyright (c) 2002 lm
# %K%

echo $N Create initial repository ...................................$NL
cat > c <<EOF
logging: none
license: $BKL_P
licsign1: $BKL_P1
licsign2: $BKL_P2
licsign3: $BKL_P3
description: BitKeeper Test repository
email: nobody@nowhere.bk
EOF
BK_HOST=bk_regression.bitkeeper.com
export BK_HOST
bk setup -f -cc project
cd project
echo foo > f
BK_USER=adam bk delta $Q -i -y'Initial checkin' f
BK_USER=adam bk commit $Q -y'Initial checkin' || exit 1
bk edit $Q f
BK_USER=second bk delta $Q -y'Second checkin' f
BK_USER=second bk commit $Q -Ssecond -y'Second checkin' || exit 1
bk edit $Q f
BK_USER=third bk delta $Q -y'Third checkin' f
BK_USER=third bk commit $Q -Sthird -y'Third checkin' || exit 1
echo OK

echo $N Check that -/search/ works ..................................$NL
bk changes -/Second/ > XXX
grep -q ChangeSet@1.3 XXX || {
	echo failed to match the 1.3 changeset
	cat XXX
	exit 1
}
for r in 1.1 1.2 1.4
do	
	grep -q ChangeSet@$r XXX && {
		echo matched the $r changeset
		cat XXX
		exit 1
	}
done
bk changes -/second/i > YYY
cmp -s XXX YYY || {
	echo Failed to match when ignoring case
	exit 1
}
echo OK

echo $N Check that dspecs work ......................................$NL
cat > WANT <<EOF
1.4
1.3
1.2
1.1
1.0
EOF
bk changes -nd:I: > XXX
cmp -s XXX WANT || {
	echo backward dpsec failed
	cat XXX
	exit 1
}

cat > WANT <<EOF
1.0
1.1
1.2
1.3
1.4
EOF
bk changes -fnd:I: > XXX
cmp -s XXX WANT || {
	echo forward dpsec failed
	cat XXX
	exit 1
}
echo OK

echo $N Check that keys work . ......................................$NL
bk prs -hr1.0.. -nd:KEY: ChangeSet | sort > WANT
bk changes -k | sort > GOT
cmp -s WANT GOT || {
	echo wrong keys
	diff WANT GOT
	exit 1
}
echo OK

echo $N Check that user restrictions work ...........................$NL
bk changes -usecond > GOT
bk changes -rsecond > WANT
cmp -s WANT GOT || {
	echo wrong answer
	diff WANT GOT
	exit 1
}
bk changes -Usecond > GOT
bk changes -r1.4,1.2,1.1,1.0 > WANT
cmp -s WANT GOT || {
	echo wrong answer
	diff WANT GOT
	exit 1
}
echo OK

echo $N Check tag listing ...........................................$NL
bk changes -t > GOT
bk changes -rthird > WANT
bk changes -rsecond >> WANT
cmp -s WANT GOT || {
	echo wrong answer
	diff WANT GOT
	exit 1
}
echo OK

echo $N Check remote/local listings .................................$NL
cd $HERE
bk clone $Q project clone
cd project
ls > LS
bk new $Q LS
BK_USER=joe bk commit $Q -yproject
cd $HERE/clone
echo hi mom > mommy
bk new $Q mommy
BK_USER=jane bk commit $Q -yclone
bk changes -L -nd':I: :P: :C:' > GOT
echo 1.5 jane clone > WANT
cmp -s WANT GOT || {
	echo local only listing failed, got 
	cat GOT
	exit 1
}
bk changes -R -nd':I: :P: :C:' > GOT
echo 1.5 joe project > WANT
cmp -s WANT GOT || {
	echo remote only listing failed, got 
	cat GOT
	exit 1
}
# cut out the newline
bk changes -L -d':I: :P: :C:' > GOT
echon 1.5 jane clone > WANT
cmp -s WANT GOT || {
	echo local only listing failed, got 
	cat GOT
	exit 1
}
bk changes -R -d':I: :P: :C:' > GOT
echo 1.5 joe project > WANT
cmp -s WANT GOT || {
	echo remote only listing failed, got 
	cat GOT
	exit 1
}
echo OK

echo $N Check remote dspec listing ..................................$NL
cd $HERE/clone
bk changes -nd':I: :P: :C:' > WANT
cd $HERE
bk changes -nd':I: :P: :C:' $HERE/clone > GOT
cmp -s clone/WANT GOT || {
	echo wrong answer
	diff WANT GOT
	exit 1
}
echo OK

echo $N Check remote search combined with dspec .....................$NL
# The /dev/null is because we exit so fast that the bkd can't update the
# logs, at least that is my theory.
cd $HERE/clone
bk changes -/Second/ -nd':I: :P: :C:' ../project > GOT 2>/dev/null
echo 1.3 second Second checkin > WANT
cmp -s WANT GOT || {
	echo remote only listing failed, got 
	cat GOT
	exit 1
}
echo OK

echo $N Check remote key listing ....................................$NL
bk prs -hr1.0.. -nd:KEY: ChangeSet | sort > WANT
cd $HERE
bk changes -k $HERE/clone | sort > GOT
cmp -s clone/WANT GOT || {
	echo wrong keys
	diff WANT GOT
	diff clone/WANT GOT
	exit 1
}
echo OK

echo $N Check remote verbose listing ................................$NL
cd $HERE/clone
bk changes -vr+ | bk undos > WANT
cd $HERE
bk changes -vr+ $HERE/clone > GOT
cmp -s clone/WANT GOT || {
	echo wrong answer
	diff clone/WANT GOT
	exit 1
}
bk lock -U
bk lock -U $HERE/clone
echo OK
echo $N Check bk changes -R url1 url2 ...............................$NL
cd $HERE
bk clone $Q  clone clone2
cd $HERE/project
bk changes -R -k $HERE/clone > keylist1
bk changes -R -k $HERE/clone $HERE/clone2 > keylist2
cmp -s keylist1 keylist2 || { echo failed; exit 1; }
cd $HERE/clone2
waitForUnlock $HERE/clone2
bk edit $Q f
echo "new" >> f
bk delta $Q -ynew f
bk commit $Q -ynew
cd $HERE/project
bk changes -R -k $HERE/clone $HERE/clone2 > keylist2
cmp -s keylist1 keylist2 && { echo failed; exit 1; }
bk prs -nhr+ -d':KEY:' $HERE/clone2/ChangeSet >> keylist1
sort keylist1 > keylist1_sorted
sort keylist2 > keylist2_sorted
cmp -s keylist1_sorted keylist2_sorted || { echo failed; exit 1; }
echo OK

echo $N Demonstrate out of order changesets .........................$NL
no_logging p
touch foo
bk new $Q foo
# The long string needed to overcome fudges.
# 1 more than need for that case where the seconds wrap during the test
bk mv foo bar
bk mv bar b
bk mv b foo
bk mv foo fee
bk commit $Q -yy
files=`bk changes -r+ -v -d:DPN:`
if [ "$files" != "ChangeSetfeefoobbarfoofoo" ]
then	echo failed; exit 1;
else	echo OK
fi
cd $HERE
rm -rf p

echo $N Demonstrate the other way they can be out of order ..........$NL
no_logging p
touch foo
bk new $Q foo
cd $HERE
bk clone $Q p c2
cd c2
touch bar
bk new $Q bar
bk commit $Q -yq
cd $HERE/p
bk commit $Q -ya
cd $HERE/c2
bk pull $Q
files=`bk changes -r1.1.1.1,1.2 -v -d:DPN:`
if [ "$files" != "ChangeSetfoofooChangeSetbarbar" ]
then	echo failed; exit 1;
else	echo OK
fi
cd $HERE
rm -rf p

echo $N Does combining restrictions work ............................$NL
cd project
revs=`bk changes -c-1Y -ujoe -d:REV:`
test X$revs != X1.5 && {
	echo failed
	exit 1
}
echo OK
