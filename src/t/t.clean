# This file is part of the BitKeeper Regression test suite.
# All of the files in this directory are Copyright (c) 2000 BitMover, Inc.
# and are not licensed under the terms of the BKL (BitKeeper License).
# Standard copyright law applies.
# 
# Redistribution in modified form is prohibited with one exception:
#    proposed modifications may be sent back to dev@bitmover.com for
#    possible inclusion in future releases.  Sending such modifications
#    constitutes your permission for BitMover, Inc. to distribute  the
#    modifications under any license.

# Copyright (c) 1999 Larry McVoy
# %K%

no_logging whatever
echo some text >X
echo other text >Y
bk delta $Q -i X Y
echo $N Remove all unmodified files .................................$NL
bk get $Q X
bk get $Q -e Y
bk clean
if [ -f X ] || [ -f Y ]; then	echo failed; exit 1; fi
echo OK
echo $N Remove only files on command line ...........................$NL
bk get $Q X Y
bk clean X
if [ -f X ] || [ ! -f Y ]; then	echo failed; exit 1; fi
echo OK
echo $N unedit should remove even modified files ....................$NL
bk get $Q -e X
echo more text >>X
bk unedit X
if [ -f X ]; then echo failed; exit 1; fi
if [ -f SCCS/p.X ]; then echo failed - still locked; exit 1; fi
echo OK
echo $N unedit should not autoexpand file names .....................$NL
for i in R S T U V
do	ls > $i
	bk new $Q $i
    	bk edit $Q $i
done
bk unedit 2>/dev/null
for i in R S T U V
do	if [ ! -f SCCS/p.$i -o ! -w $i ]
	then	echo failed on $i; exit 1
	fi
done
echo OK
echo $N unlock should not autoexpand file names .....................$NL
bk unlock 2>/dev/null
for i in R S T U V
do	if [ ! -f SCCS/p.$i -o ! -w $i ]
	then	echo failed on $i; exit 1
	fi
done
echo OK
echo $N clean should autoexpand file names ..........................$NL
bk clean 2>/dev/null
for i in R S T U V
do	if [ -f SCCS/p.$i -o -w $i ]
	then	echo failed on $i; exit 1
	fi
done
echo OK
echo $N unlock should fail if gfile is there ........................$NL
bk get $Q -e X
echo more text >>X
bk unlock X 2>/dev/null
if [ $? != 1 ]; then echo failed to exit 1; exit 1; fi
if [ ! -f SCCS/p.X ]; then echo failed to leave p.file; exit 1; fi
echo OK
echo $N unlock -x should work .......................................$NL
touch SCCS/x.X SCCS/z.X SCCS/b.X
bk unlock -x X  2> /dev/null
if [ ! -f X ]; then echo failed; exit 1; fi
if [ -f SCCS/x.X ]; then echo failed - left x; exit 1; fi
if [ ! -f SCCS/b.X -o ! -f SCCS/z.X -o ! -f SCCS/p.X ]
then echo failed - deleted other lock files; ls SCCS/?.X; exit 1; fi
echo OK
echo $N unlock -z should work .......................................$NL
touch SCCS/x.X SCCS/z.X SCCS/b.X
bk unlock -z X 2>/dev/null
if [ ! -f X ]; then echo failed; exit 1; fi
if [ -f SCCS/z.X ]; then echo failed - left z; exit 1; fi
if [ ! -f SCCS/b.X -o ! -f SCCS/x.X -o ! -f SCCS/p.X ]
then echo failed - deleted other lock files; exit 1; fi
echo OK
echo $N unlock -zx should work ......................................$NL
touch SCCS/x.X SCCS/z.X 
bk unlock -xz X 2>/dev/null
if [ ! -f X ]; then echo failed; exit 1; fi
if [ -f SCCS/z.X -o -f SCCS/x.X ]
then echo failed - left lock files; exit 1; fi
echo OK
echo $N unlock -fpzx should work ....................................$NL
touch SCCS/x.X SCCS/z.X
bk unlock -fpxz X 2>/dev/null
if [ ! -f X ]; then echo failed; exit 1; fi
if [ ! -f SCCS/s.X ]; then echo failed; exit 1; fi
if [ -f SCCS/z.X -o -f SCCS/x.X -o -f SCCS/p.X ]
then echo failed - left lock files; exit 1; fi
echo OK
rm -f CMP1 CMP2 X Y SCCS/?.X SCCS/?.Y
# Test internal compare for RCS, SCCS, EXPAND1, nonewline, binary, longline
# and hash data.  Uses clean to test diffs (in some cases uses sfiles -c
fail=no
echo $N No change to a regular file .................................$NL
echo reg > reg
bk ci $Q -i reg
bk get $Q -e reg
bk clean $Q reg
if [ $? -ne 0 ] ; then echo failed; fail=yes; else echo OK; fi
echo $N No change to a no newline ending file .......................$NL
echo $N nonl$NL > nonl
bk ci $Q -i nonl
bk get $Q -e nonl
bk clean $Q nonl
if [ $? -ne 0 ] ; then echo failed; fail=yes; else echo OK; fi
echo $N No change to a longline file ................................$NL
str=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
str=${str}${str}${str}${str}${str}${str}${str}${str}${str}${str}${str}${str}
str=${str}${str}${str}${str}${str}${str}${str}${str}${str}${str}${str}${str}
echo $str > long
bk ci $Q -i long
bk get $Q -e long
bk clean $Q long
if [ $? -ne 0 ] ; then echo failed; fail=yes; else echo OK; fi
echo $N No change to a hash file ....................................$NL
echo hash first > hash
bk ci $Q -i -h hash
bk get $Q -e hash
echo hash second > hash
bk delta $Q -yhash hash
bk get $Q -e hash
bk clean $Q hash
if [ $? -ne 0 ] ; then echo failed; fail=yes; else echo OK; fi
echo $N No change to SCCS expand file .. check sfiles -c ............$NL
echo %""K% > sccsexp
bk ci $Q -i sccsexp
bk get $Q sccsexp
mv sccsexp sccsexp.expn
bk get $Q -e sccsexp
rm -f sccsexp
mv sccsexp.expn sccsexp
chmod +w sccsexp
result=`bk sfiles -c sccsexp | wc -l`
if [ $result -ne 1 ] ; then echo failed; fail=yes; else echo OK; fi
echo $N No change to SCCS expand file .. check clean ................$NL
bk clean $Q sccsexp
if [ $? -ne 0 ] ; then echo failed; fail=yes; else echo OK; fi
echo $N No change to RCS expand file ....check sfiles -c ............$NL
echo '$Revision$' > rcsexp
bk ci $Q -i rcsexp
bk admin -fRCS rcsexp
bk get $Q rcsexp
mv rcsexp rcsexp.expn
bk get $Q -e rcsexp
rm -f rcsexp
mv rcsexp.expn rcsexp
chmod +w rcsexp
result=`bk sfiles -c rcsexp | wc -l`
if [ $result -ne 1 ] ; then echo failed; fail=yes; else echo OK; fi
echo $N No change to RCS expand file ....check clean ................$NL
bk unedit rcsexp
bk edit $Q rcsexp
bk clean $Q rcsexp
if [ $? -ne 0 ] ; then echo failed; fail=yes; else echo OK; fi
echo $N No change to expand first keyword only .. check sfiles -c ...$NL
echo %""@% > exp1 
echo %""K% >> exp1 
bk ci $Q -i exp1
bk get $Q exp1
mv exp1 exp1.expn
bk get $Q -e exp1
rm -f exp1
mv exp1.expn exp1
chmod +w exp1
result=`bk sfiles -c exp1 | wc -l`
if [ $result -ne 1 ] ; then echo failed; fail=yes; else echo OK; fi
echo $N No change to expand first keyword only .. check clean .......$NL
bk clean $Q exp1
if [ $? -ne 0 ] ; then echo failed; fail=yes; else echo OK; fi
echo $N Removing the newline from a file which used to have one .....$NL
echo hadnl > hadnl
bk ci $Q -i hadnl
bk get $Q -e hadnl
echo $N hadnl$NL > hadnl
bk clean $Q hadnl
if [ $? -eq 0 ] ; then echo failed; fail=yes; else echo OK; fi
echo $N Adding a newline to a file which did not have one ...........$NL
echo $N nothadnl$NL > nothadnl
bk ci $Q -i nothadnl
bk get $Q -e nothadnl
echo nothadnl > nothadnl
bk clean $Q nothadnl
if [ $? -eq 0 ] ; then echo failed; fail=yes; else echo OK; fi
echo $N No change to a file which initially had no newline ..........$NL
echo $N initnonl$NL > initnonl
bk ci $Q -i initnonl
bk get $Q -e initnonl
echo initnonl > initnonl
bk delta $Q -yinitnonl initnonl
bk get $Q -e initnonl
bk clean $Q initnonl
if [ $? -ne 0 ] ; then echo failed; fail=yes; else echo OK; fi
echo $N Initially had no newline, then deleted last line ............$NL
echo first > initdel
echo $N initdel$NL >> initdel
bk ci $Q -i initdel
bk get $Q -e initdel
echo first > initdel
bk delta $Q -yinitdel initdel
bk get $Q -e initdel
bk clean $Q initdel
if [ $? -ne 0 ] ; then echo failed; fail=yes; else echo OK; fi
echo $N Hash change new key in gfile ................................$NL
echo newkey first > newkey
bk ci $Q -i -h newkey
bk get $Q -e newkey
echo morenewkey second > newkey
echo newkey first >> newkey
bk clean $Q newkey
if [ $? -eq 0 ] ; then echo failed; fail=yes; else echo OK; fi
#NOTE: deleted keys not supported at this time
#echo $N Hash change del key in gfile ................................$NL
#echo delkey first > delkey
#echo moredelkey second >> delkey
#ci $Q -i -h delkey
#get $Q -e delkey
#echo moredelkey second > delkey
#clean $Q delkey
#if [ $? -eq 0 ] ; then echo failed; fail=yes; else echo OK; fi
echo $N Hash change val in gfile ....................................$NL
echo newval first > newval
bk ci $Q -i -h newval
bk get $Q -e newval
echo newval last > newval
bk clean $Q newval
if [ $? -eq 0 ] ; then echo failed; fail=yes; else echo OK; fi
echo $N Hash diff is order independent ..............................$NL
echo orderind first > orderind
echo morekey next >> orderind
bk ci $Q -i -h orderind
bk get $Q -e orderind
echo morekey next > orderind
echo orderind first >> orderind
bk clean $Q orderind
if [ $? -ne 0 ] ; then echo failed; fail=yes; else echo OK; fi
if [ $fail = yes ] ; then exit 1; fi
